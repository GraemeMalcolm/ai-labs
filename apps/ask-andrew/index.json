[
  {
    "id": 1,
    "category": "Generative AI",
    "file": "01-language-models.md",
    "heading": "Tokenization",
    "content": "The first step is to provide the model with a large vocabulary of words and phrases; and we do mean *large*. The latest generation of LLMs have vocabularies that consist of hundreds of thousands of tokens, based on large volumes of training data from across the Internet and other sources.\n\nWait a minute. *Tokens*?\n\nWhile we tend to think of language in terms of *words*, LLMs break down their vocabulary into *tokens*. Tokens include words, but also *sub*-words (like the \"un\" in \"unbelievable\" and",
    "summary": "The first step is to provide the model with a large vocabulary of words and phrases; and we do mean *large*. The latest generation of LLMs have vocabularies that consist of hundreds of thousands of to...",
    "keywords": [
      "internet",
      "added",
      "sequences",
      "llms",
      "first",
      "assign",
      "across",
      "sources",
      "tokenization",
      "break",
      "into",
      "consist",
      "heard",
      "tokens",
      "model",
      "tend",
      "like",
      "used",
      "hundreds",
      "step"
    ]
  },
  {
    "id": 2,
    "category": "Generative AI",
    "file": "01-language-models.md",
    "heading": "Transforming tokens with a *transformer*",
    "content": "Now that we have a set of tokens with unique IDs, we need to find a way to relate them to one another. To do this, we assign each token a *vector* (an array of multiple numeric values, like [1, 23, 45]). Each vector has multiple numeric *elements* or *dimensions*, and we can use these to encode linguistic and semantic attributes of the token to help provide a great deal of information about what the token *means* and how it relates to other tokens, in an efficient format.\n\nWe need to transform t",
    "summary": "Now that we have a set of tokens with unique IDs, we need to find a way to relate them to one another. To do this, we assign each token a *vector* (an array of multiple numeric values, like [1, 23, 45...",
    "keywords": [
      "blocks",
      "format",
      "next",
      "prompt",
      "neural",
      "architecture",
      "assign",
      "call",
      "attention",
      "sequence",
      "semantic",
      "vectors",
      "consists",
      "evaluate",
      "applying",
      "because",
      "each",
      "uses",
      "contexts",
      "kind"
    ]
  },
  {
    "id": 3,
    "category": "Generative AI",
    "file": "01-language-models.md",
    "heading": "Initial vectors and positional encoding",
    "content": "Initially, the token vector values are assigned randomly, before being fed through the transformer to create embedding vectors. The token vectors are fed into the transformer along with a *positional encoding* that indicates where the token appears in the sequence of training text (we need to do this because the order in which tokens appear in the sequence is relevant to how they relate to one another). For example, our tokens might start off looking like this:\n\n|Token | Token ID | Position | Ve",
    "summary": "Initially, the token vector values are assigned randomly, before being fed through the transformer to create embedding vectors. The token vectors are fed into the transformer along with a *positional...",
    "keywords": [
      "example",
      "along",
      "values",
      "relate",
      "indicates",
      "initial",
      "into",
      "heard",
      "tokens",
      "where",
      "start",
      "transformer",
      "sequence",
      "like",
      "encoding",
      "vectors",
      "vector",
      "before",
      "embedding",
      "because"
    ]
  },
  {
    "id": 4,
    "category": "Generative AI",
    "file": "01-language-models.md",
    "heading": "Attention and embeddings",
    "content": "To determine the vector representations of tokens that include embedded contextual information, the transformer uses *attention* layers. An attention layer considers each token in turn, within the context of the sequence of tokens in which it appears. The tokens around the current one are weighted to reflect their influence and the weights are used to calculate the element values for the current token's embedding vector. For example, when considering the token \"bark\" in the context of \"I heard a",
    "summary": "To determine the vector representations of tokens that include embedded contextual information, the transformer uses *attention* layers. An attention layer considers each token in turn, within the con...",
    "keywords": [
      "important",
      "meanings",
      "assign",
      "start",
      "attention",
      "sequence",
      "patterns",
      "semantic",
      "vectors",
      "current",
      "because",
      "observant",
      "uses",
      "each",
      "text",
      "contexts",
      "commonly",
      "considering",
      "appear",
      "another"
    ]
  },
  {
    "id": 5,
    "category": "Generative AI",
    "file": "01-language-models.md",
    "heading": "Predicting completions from prompts",
    "content": "Now that we have a set of embeddings that encapsulate the contextual relationship between tokens, we can use the *decoder* block of a transformer to iteratively predict the next word in a sequence based on a starting *prompt*.\n\nOnce again, *attention* is used to consider each token in context; but this time the context to be considered can only include the tokens that *precede* the token we're trying to predict. The decoder model is trained, using data for which we already have the full sequence",
    "summary": "Now that we have a set of embeddings that encapsulate the contextual relationship between tokens, we can use the *decoder* block of a transformer to iteratively predict the next word in a sequence bas...",
    "keywords": [
      "next",
      "prompt",
      "assign",
      "between",
      "attention",
      "sequence",
      "vectors",
      "current",
      "evaluate",
      "applying",
      "each",
      "rather",
      "value",
      "completion",
      "skateboard",
      "possible",
      "during",
      "error",
      "than",
      "predict"
    ]
  },
  {
    "id": 6,
    "category": "Generative AI",
    "file": "02-writing-prompts.md",
    "heading": "Types of prompt",
    "content": "There are two main types of prompts:\n\n- **System prompts** that set the behavior and tone of the model, and any constraints it should adhere to. For example, \"*You're a helpful assistant that responds in a cheerful, friendly manner.*\". System prompts determine constraints and styles for the model's responses.\n- **User prompts** that elicit a response to a specific question or instruction. For example, \"*Summarize the key considerations for adopting generative AI described in <u>GenAI_Considerati",
    "summary": "There are two main types of prompts:\n\n- **System prompts** that set the behavior and tone of the model, and any constraints it should adhere to. For example, \"*You're a helpful assistant that responds...",
    "keywords": [
      "types",
      "example",
      "format",
      "response",
      "prompt",
      "elicit",
      "assistant",
      "some",
      "behalf",
      "model",
      "summary",
      "application",
      "generated",
      "main",
      "instruction",
      "entered",
      "considerations",
      "behavior",
      "tone",
      "summarize"
    ]
  },
  {
    "id": 7,
    "category": "Generative AI",
    "file": "02-writing-prompts.md",
    "heading": "Conversation history",
    "content": "To keep a conversation consistent and relevant, generative AI apps often keep track of the conversation history; and include summarized versions of it in subsequent prompts. This ensures there’s an ongoing context for the conversation that the model can build on.\n\n![Diagram of a conversation with multiple prompts and completions.](../media/conversation-history.png)\n\nFor example, suppose the model responds to the system and user prompts described previously with the following completion:\n\n> *Key ",
    "summary": "To keep a conversation consistent and relevant, generative AI apps often keep track of the conversation history; and include summarized versions of it in subsequent prompts. This ensures there’s an on...",
    "keywords": [
      "privacy-related",
      "such",
      "shifts",
      "conversation-history",
      "prompt",
      "conversation",
      "foster",
      "responsible",
      "readiness",
      "ensures",
      "relation",
      "subsequent",
      "mitigate",
      "there",
      "follow-up",
      "versions",
      "governance",
      "prioritize",
      "completion",
      "system"
    ]
  },
  {
    "id": 8,
    "category": "Generative AI",
    "file": "02-writing-prompts.md",
    "heading": "Retrieval augmented generation (RAG)",
    "content": "To add even more context, generative AI applications can use a technique called *retrieval augmented generation (RAG)*. This approach involves retrieving information, like documents or emails, and using it to augment the prompt with relevant data. The response generated by the model is then *grounded* in the information that was provided.\n\nFor example, suppose you submit a prompt like \"*What's the maximum I can claim for travel expenses on a business trip?*\". With no other information, a model w",
    "summary": "To add even more context, generative AI applications can use a technique called *retrieval augmented generation (RAG)*. This approach involves retrieving information, like documents or emails, and usi...",
    "keywords": [
      "sent",
      "queries",
      "technique",
      "example",
      "maximum",
      "response",
      "along",
      "augmented",
      "even",
      "documents",
      "prompt",
      "claim",
      "expenses",
      "better",
      "related",
      "assistant",
      "context",
      "information",
      "what",
      "documentation"
    ]
  },
  {
    "id": 9,
    "category": "Generative AI",
    "file": "02-writing-prompts.md",
    "heading": "Tips for better prompts",
    "content": "The quality of responses from generative AI assistants not only depends on the language model used, but on the prompts you submit to it.\n\n![Diagram of a clear and specific prompt with context, examples, and a request for structure.](../media/writing-prompts.png)\n\nTo get better results from your prompts:\n\n- Be **clear** and **specific** – prompts with explicit instructions or questions work better than vague language.\n- Add **context** - mention the topic, audience, or format you want.\n- Use **ex",
    "summary": "The quality of responses from generative AI assistants not only depends on the language model used, but on the prompts you submit to it.\n\n![Diagram of a clear and specific prompt with context, example...",
    "keywords": [
      "work",
      "numbered",
      "results",
      "example",
      "format",
      "better",
      "prompt",
      "difference",
      "questions",
      "request",
      "context",
      "style",
      "depends",
      "what",
      "model",
      "certain",
      "like",
      "used",
      "examples",
      "mean"
    ]
  },
  {
    "id": 10,
    "category": "Generative AI",
    "file": "03-agents.md",
    "heading": "Components of an AI agent",
    "content": "![Diagram of an agent with a model, instructions, and tools.](../media/agent.png)\n\nAI agents have three key elements:\n\n- **A large language model**: This is the agent's brain; using generative AI for language understanding and reasoning.\n- **Instructions**: A system prompt that defines the agent’s role and behavior. Think of it as the agent’s job description.\n- **Tools**: These are what the agent uses to interact with the world. Tools can include:\n    - *Knowledge* tools that provide access to i",
    "summary": "![Diagram of an agent with a model, instructions, and tools.](../media/agent.png)\n\nAI agents have three key elements:\n\n- **A large language model**: This is the agent's brain; using generative AI for...",
    "keywords": [
      "work",
      "perform",
      "such",
      "components",
      "reasoning",
      "world",
      "prompt",
      "interact",
      "enable",
      "three",
      "intelligently",
      "take",
      "access",
      "understanding",
      "information",
      "what",
      "calendars",
      "model",
      "automate",
      "like"
    ]
  },
  {
    "id": 11,
    "category": "Generative AI",
    "file": "03-agents.md",
    "heading": "Multi-agent systems",
    "content": "Agents can also work with one another, in multi-agent systems. Instead of one agent doing everything, multiple agents can collaborate—each with its own specialty. One might gather data, another might analyze it, and a third might take action. Together, they form an AI-powered workforce that can handle complex workflows, just like a human team.\n\n![Diagram of a multi-agent system.](../media/multiple-agents.png)\n\nAgents communicate with each other through prompts, using generative AI to determine w",
    "summary": "Agents can also work with one another, in multi-agent systems. Instead of one agent doing everything, multiple agents can collaborate—each with its own specialty. One might gather data, another might...",
    "keywords": [
      "work",
      "third",
      "together",
      "them",
      "next",
      "ai-powered",
      "multiple",
      "analyze",
      "workforce",
      "take",
      "responsible",
      "systems",
      "what",
      "agentic",
      "information",
      "like",
      "complex",
      "done",
      "handle",
      "each"
    ]
  },
  {
    "id": 12,
    "category": "Machine Learning",
    "file": "02-types-of-machine-learning.md",
    "heading": "Supervised machine learning",
    "content": "*Supervised* machine learning is a general term for machine learning algorithms in which the training data includes both *feature* values and known *label* values. Supervised machine learning is used to train models by determining a relationship between the features and labels in past observations, so that unknown labels can be predicted for features in future cases.",
    "summary": "*Supervised* machine learning is a general term for machine learning algorithms in which the training data includes both *feature* values and known *label* values. Supervised machine learning is used...",
    "keywords": [
      "future",
      "feature",
      "machine",
      "values",
      "predicted",
      "term",
      "between",
      "labels",
      "observations",
      "both",
      "used",
      "includes",
      "known",
      "which",
      "supervised",
      "general",
      "data",
      "learning",
      "cases",
      "past"
    ]
  },
  {
    "id": 13,
    "category": "Machine Learning",
    "file": "02-types-of-machine-learning.md",
    "heading": "Regression",
    "content": "*Regression* is a form of supervised machine learning in which the label predicted by the model is a numeric value. For example:\n\n- The number of ice creams sold on a given day, based on the temperature, rainfall, and windspeed.\n- The selling price of a property based on its size in square feet, the number of bedrooms it contains, and socio-economic metrics for its location.\n- The fuel efficiency (in miles-per-gallon) of a car based on its engine size, weight, width, height, and length.",
    "summary": "*Regression* is a form of supervised machine learning in which the label predicted by the model is a numeric value. For example:\n\n- The number of ice creams sold on a given day, based on the temperatu...",
    "keywords": [
      "temperature",
      "example",
      "property",
      "machine",
      "numeric",
      "square",
      "predicted",
      "miles-per-gallon",
      "selling",
      "model",
      "efficiency",
      "height",
      "feet",
      "price",
      "regression",
      "which",
      "supervised",
      "based",
      "learning",
      "number"
    ]
  },
  {
    "id": 14,
    "category": "Machine Learning",
    "file": "02-types-of-machine-learning.md",
    "heading": "Classification",
    "content": "*Classification* is a form of supervised machine learning in which the label represents a categorization, or *class*. There are two common classification scenarios.",
    "summary": "*Classification* is a form of supervised machine learning in which the label represents a categorization, or *class*. There are two common classification scenarios.",
    "keywords": [
      "common",
      "represents",
      "machine",
      "classification",
      "scenarios",
      "there",
      "which",
      "form",
      "categorization",
      "class",
      "supervised",
      "learning",
      "label"
    ]
  },
  {
    "id": 15,
    "category": "Machine Learning",
    "file": "02-types-of-machine-learning.md",
    "heading": "Binary classification",
    "content": "In *binary classification*, the label determines whether the observed item *is* (or *isn't*) an instance of a specific class. Or put another way, binary classification models predict one of two mutually exclusive outcomes. For example:\n\n- Whether a patient is at risk for diabetes based on clinical metrics like weight, age, blood glucose level, and so on.\n- Whether a bank customer will default on a loan based on income, credit history, age, and other factors.\n- Whether a mailing list customer wil",
    "summary": "In *binary classification*, the label determines whether the observed item *is* (or *isn't*) an instance of a specific class. Or put another way, binary classification models predict one of two mutual...",
    "keywords": [
      "loan",
      "clinical",
      "example",
      "positively",
      "risk",
      "observed",
      "prediction",
      "negative",
      "exclusive",
      "glucose",
      "determines",
      "marketing",
      "model",
      "mutually",
      "whether",
      "patient",
      "like",
      "true",
      "purchases",
      "default"
    ]
  },
  {
    "id": 16,
    "category": "Machine Learning",
    "file": "02-types-of-machine-learning.md",
    "heading": "Multiclass classification",
    "content": "*Multiclass classification* extends binary classification to predict a label that represents one of multiple possible classes. For example,\n\n- The species of a penguin (*Adelie*, *Gentoo*, or *Chinstrap*) based on its physical measurements.\n- The genre of a movie (*comedy*, *horror*, *romance*, *adventure*, or *science fiction*) based on its cast, director, and budget.\n\nIn most scenarios that involve a known set of multiple classes, multiclass classification is used to predict mutually exclusive",
    "summary": "*Multiclass classification* extends binary classification to predict a label that represents one of multiple possible classes. For example,\n\n- The species of a penguin (*Adelie*, *Gentoo*, or *Chinstr...",
    "keywords": [
      "classes",
      "example",
      "categorized",
      "horror",
      "multiple",
      "observation",
      "extends",
      "adventure",
      "exclusive",
      "science",
      "some",
      "labels",
      "involve",
      "mutually",
      "used",
      "both",
      "adelie",
      "scenarios",
      "measurements",
      "known"
    ]
  },
  {
    "id": 17,
    "category": "Machine Learning",
    "file": "02-types-of-machine-learning.md",
    "heading": "Unsupervised machine learning",
    "content": "*Unsupervised* machine learning involves training models using data that consists only of *feature* values without any known labels. Unsupervised machine learning algorithms determine relationships between the features of the observations in the training data.",
    "summary": "*Unsupervised* machine learning involves training models using data that consists only of *feature* values without any known labels. Unsupervised machine learning algorithms determine relationships be...",
    "keywords": [
      "feature",
      "machine",
      "values",
      "between",
      "labels",
      "without",
      "observations",
      "consists",
      "only",
      "known",
      "determine",
      "learning",
      "data",
      "involves",
      "relationships",
      "features",
      "algorithms",
      "models",
      "using",
      "unsupervised"
    ]
  },
  {
    "id": 18,
    "category": "Machine Learning",
    "file": "02-types-of-machine-learning.md",
    "heading": "Clustering",
    "content": "The most common form of unsupervised machine learning is *clustering*. A clustering algorithm identifies similarities between observations based on their features, and groups them into discrete clusters. For example:\n\n- Group similar flowers based on their size, number of leaves, and number of petals.\n- Identify groups of similar customers based on demographic attributes and purchasing behavior.\n\nIn some ways, clustering is similar to multiclass classification; in that it categorizes observation",
    "summary": "The most common form of unsupervised machine learning is *clustering*. A clustering algorithm identifies similarities between observations based on their features, and groups them into discrete cluste...",
    "keywords": [
      "volume",
      "machine",
      "petals",
      "similarities",
      "between",
      "behavior",
      "known",
      "categorize",
      "features",
      "there",
      "value",
      "label",
      "train",
      "common",
      "using",
      "purchaser",
      "exist",
      "groups",
      "them",
      "analyze"
    ]
  },
  {
    "id": 19,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Example - regression",
    "content": "Let's explore regression with a simplified example in which we'll train a model to predict a numeric label (***y***) based on a single feature value (***x***). Most real scenarios involve multiple feature values, which adds some complexity; but the principle is the same.\n\nFor our example, let's stick with the ice cream sales scenario we discussed previously. For our feature, we'll consider the *temperature* (let's assume the value is the maximum temperature on a given day), and the label we want",
    "summary": "Let's explore regression with a simplified example in which we'll train a model to predict a numeric label (***y***) based on a single feature value (***x***). Most real scenarios involve multiple fea...",
    "keywords": [
      "feature",
      "temperature",
      "example",
      "maximum",
      "discussed",
      "thermometer",
      "values",
      "sales",
      "numeric",
      "multiple",
      "previously",
      "consider",
      "stick",
      "historic",
      "some",
      "model",
      "involve",
      "start",
      "cream",
      "adds"
    ]
  },
  {
    "id": 20,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Training a regression model",
    "content": "We'll start by splitting the data and using a subset of it to train a model. Here's the training dataset:\n\n|Temperature (x) | Ice cream sales (y)|\n|---|---|\n|51|1|\n|65|14|\n|69|20|\n|72|23|\n|75|26|\n|81|30|\n\nTo get an insight of how these ***x*** and ***y*** values might relate to one another, we can plot them as coordinates along two axes, like this:\n\n![Diagram of a scatter plot showing x and y.](../media/scatter-plot.png)\n\nNow we're ready to apply an algorithm to our training data and fit it to a",
    "summary": "We'll start by splitting the data and using a subset of it to train a model. Here's the training dataset:\n\n|Temperature (x) | Ice cream sales (y)|\n|---|---|\n|51|1|\n|65|14|\n|69|20|\n|72|23|\n|75|26|\n|81|...",
    "keywords": [
      "such",
      "scatter-plot",
      "regression-line",
      "between",
      "start",
      "accurate",
      "tomorrow",
      "distance",
      "axis",
      "creams",
      "average",
      "value",
      "another",
      "applies",
      "points",
      "train",
      "minimizing",
      "while",
      "predict",
      "using"
    ]
  },
  {
    "id": 21,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Evaluating a regression model",
    "content": "To validate the model and evaluate how well it predicts, we held back some data for which we know the label (***y***) value. Here's the data we held back:\n\n|Temperature (x) | Ice cream sales (y)|\n|---|---|\n|52|0|\n|67|14|\n|70|23|\n|73|22|\n|78|26|\n|83|36|\n\nWe can use the model to predict the label for each of the observations in this dataset based on the feature (***x***) value; and then compare the predicted label (***&#375;***) to the known actual label value (***y***).\n\nUsing the model we traine",
    "summary": "To validate the model and evaluate how well it predicts, we held back some data for which we know the label (***y***) value. Here's the data we held back:\n\n|Temperature (x) | Ice cream sales (y)|\n|---...",
    "keywords": [
      "temperature",
      "feature",
      "results",
      "compare",
      "sales",
      "values",
      "following",
      "predicted",
      "regression-variance",
      "encapsulates",
      "prediction",
      "earlier",
      "some",
      "held",
      "between",
      "model",
      "well",
      "labels",
      "observations",
      "cream"
    ]
  },
  {
    "id": 22,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Regression evaluation metrics",
    "content": "Based on the differences between the predicted and actual values, you can calculate some common metrics that are used to evaluate a regression model.",
    "summary": "Based on the differences between the predicted and actual values, you can calculate some common metrics that are used to evaluate a regression model.",
    "keywords": [
      "used",
      "common",
      "metrics",
      "regression",
      "actual",
      "values",
      "predicted",
      "calculate",
      "evaluate",
      "differences",
      "some",
      "between",
      "based",
      "model",
      "evaluation"
    ]
  },
  {
    "id": 23,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Mean Absolute Error (MAE)",
    "content": "The variance in this example indicates by how many ice creams each prediction was wrong. It doesn't matter if the prediction was *over* or *under* the actual value (so for example, -3 and +3 both indicate a variance of 3). This metric is known as the *absolute error* for each prediction, and can be summarized for the whole validation set as the **mean absolute error** (MAE).\n\nIn the ice cream example, the mean (average) of the absolute errors (2, 3, 3, 1, 2, and 3) is **2.33**.",
    "summary": "The variance in this example indicates by how many ice creams each prediction was wrong. It doesn't matter if the prediction was *over* or *under* the actual value (so for example, -3 and +3 both indi...",
    "keywords": [
      "example",
      "wrong",
      "indicates",
      "prediction",
      "absolute",
      "cream",
      "both",
      "doesn",
      "mean",
      "indicate",
      "known",
      "each",
      "actual",
      "errors",
      "metric",
      "validation",
      "variance",
      "creams",
      "under",
      "average"
    ]
  },
  {
    "id": 24,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Mean Squared Error (MSE)",
    "content": "The mean absolute error metric takes all discrepancies between predicted and actual labels into account equally. However, it may be more desirable to have a model that is consistently wrong by a small amount than one that makes fewer, but larger errors. One way to produce a metric that \"amplifies\" larger errors by *squaring* the individual errors and calculating the mean of the squared values. This metric is known as the **mean squared error** (MSE).\n\nIn our ice cream example, the mean of the sq",
    "summary": "The mean absolute error metric takes all discrepancies between predicted and actual labels into account equally. However, it may be more desirable to have a model that is consistently wrong by a small...",
    "keywords": [
      "makes",
      "example",
      "individual",
      "values",
      "takes",
      "wrong",
      "predicted",
      "equally",
      "into",
      "account",
      "between",
      "model",
      "labels",
      "absolute",
      "cream",
      "amount",
      "squaring",
      "small",
      "amplifies",
      "mean"
    ]
  },
  {
    "id": 25,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Root Mean Squared Error (RMSE)",
    "content": "The mean squared error helps take the magnitude of errors into account, but because it *squares* the error values, the resulting metric no longer represents the quantity measured by the label. In other words, we can say that the MSE of our model is 6, but that doesn't measure its accuracy in terms of the number of ice creams that were mispredicted; 6 is just a numeric score that indicates the level of error in the validation predictions.\n\nIf we want to measure the error in terms of the number of",
    "summary": "The mean squared error helps take the magnitude of errors into account, but because it *squares* the error values, the resulting metric no longer represents the quantity measured by the label. In othe...",
    "keywords": [
      "quantity",
      "mispredicted",
      "helps",
      "values",
      "numeric",
      "square",
      "indicates",
      "calculate",
      "case",
      "resulting",
      "take",
      "into",
      "account",
      "unsurprisingly",
      "magnitude",
      "model",
      "measure",
      "doesn",
      "mean",
      "measured"
    ]
  },
  {
    "id": 26,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Coefficient of determination (R<sup>2</sup>)",
    "content": "All of the metrics so far compare the discrepancy between the predicted and actual values in order to evaluate the model. However, in reality, there's some natural random variance in the daily sales of ice cream that the model takes into account. In a linear regression model, the training algorithm fits a straight line that minimizes the mean variance between the function and the known label values. The **coefficient of determination** (more commonly referred to as **R<sup>2</sup>** or **R-Squar",
    "summary": "All of the metrics so far compare the discrepancy between the predicted and actual values in order to evaluate the model. However, in reality, there's some natural random variance in the daily sales o...",
    "keywords": [
      "machine",
      "important",
      "takes",
      "account",
      "between",
      "labels",
      "worry",
      "evaluate",
      "known",
      "because",
      "actual",
      "commonly",
      "discrepancy",
      "creams",
      "there",
      "value",
      "fitting",
      "anomalous",
      "calculation",
      "calculated"
    ]
  },
  {
    "id": 27,
    "category": "Machine Learning",
    "file": "03-regression.md",
    "heading": "Iterative training",
    "content": "The metrics described above are commonly used to evaluate a regression model. In most real-world scenarios, a data scientist will use an iterative process to repeatedly train and evaluate a model, varying:\n\n- Feature selection and preparation (choosing which features to include in the model, and calculations applied to them to help ensure a better fit).\n- Algorithm selection (We explored linear regression in the previous example, but there are many other regression algorithms)\n- Algorithm parame",
    "summary": "The metrics described above are commonly used to evaluate a regression model. In most real-world scenarios, a data scientist will use an iterative process to repeatedly train and evaluate a model, var...",
    "keywords": [
      "above",
      "feature",
      "results",
      "example",
      "them",
      "numeric",
      "better",
      "multiple",
      "linear",
      "explored",
      "differentiate",
      "model",
      "acceptable",
      "evaluation",
      "used",
      "process",
      "varying",
      "regression",
      "iterations",
      "scenarios"
    ]
  },
  {
    "id": 28,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Example - binary classification",
    "content": "To understand how binary classification works, let's look at a simplified example that uses a single feature (***x***) to predict whether the label ***y*** is 1 or 0. In this example, we'll use the blood glucose level of a patient to predict whether or not the patient has diabetes. Here's the data with which we'll train the model:\n\n|![Diagram of a syringe.](../media/blood-glucose.png)|![Diagram of a diabetic and non-diabetic person.](../media/diabetes.png)|\n|---|---|\n|**Blood glucose (x)** | **D",
    "summary": "To understand how binary classification works, let's look at a simplified example that uses a single feature (***x***) to predict whether the label ***y*** is 1 or 0. In this example, we'll use the bl...",
    "keywords": [
      "feature",
      "example",
      "look",
      "person",
      "understand",
      "glucose",
      "model",
      "whether",
      "patient",
      "level",
      "works",
      "uses",
      "which",
      "data",
      "media",
      "blood-glucose",
      "blood",
      "diabetes",
      "classification",
      "syringe"
    ]
  },
  {
    "id": 29,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Training a binary classification model",
    "content": "To train the model, we'll use an algorithm to fit the training data to a function that calculates the *probability* of the class label being *true* (in other words, that the patient has diabetes). Probability is measured as a value between 0.0 and 1.0, such that the *total* probability for *all* possible classes is 1.0. So for example, if the probability of a patient having diabetes is 0.7, then there's a corresponding probability of 0.3 that the patient isn't</u> diabetic.\n\nThere are many algor",
    "summary": "To train the model, we'll use an algorithm to fit the training data to a function that calculates the *probability* of the class label being *true* (in other words, that the patient has diabetes). Pro...",
    "keywords": [
      "such",
      "higher",
      "between",
      "patient",
      "calculates",
      "mathematically",
      "level",
      "corresponding",
      "sigmoid-plot",
      "lies",
      "total",
      "there",
      "value",
      "threshold",
      "label",
      "possible",
      "train",
      "than",
      "result",
      "while"
    ]
  },
  {
    "id": 30,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Evaluating a binary classification model",
    "content": "As with regression, when training a binary classification model you hold back a random subset of data with which to validate the trained model. Let's assume we held back the following data to validate our diabetes classifier:\n\n|Blood glucose (x) | Diabetic? (y)|\n|---|---|\n|66|0|\n|107|1|\n|112|1|\n|71|0|\n|87|1|\n|89|1|\n\nApplying the logistic function we derived previously to the ***x*** values results in the following plot. \n\n![Diagram of predicted labels on a sigmoid curve.](../media/classification",
    "summary": "As with regression, when training a binary classification model you hold back a random subset of data with which to validate the trained model. Let's assume we held back the following data to validate...",
    "keywords": [
      "above",
      "results",
      "below",
      "compare",
      "previously",
      "values",
      "following",
      "when",
      "predicted",
      "observation",
      "held",
      "glucose",
      "model",
      "labels",
      "logistic",
      "whether",
      "then",
      "random",
      "regression",
      "subset"
    ]
  },
  {
    "id": 31,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Binary classification evaluation metrics",
    "content": "The first step in calculating evaluation metrics for a binary classification model is usually to create a matrix of the number of correct and incorrect predictions for each possible class label:\n\n![Diagram of a confusion matrix.](../media/binary-confusion-matrix.png)\n\nThis visualization is called a *confusion matrix*, and it shows the prediction totals where:\n\n- &#375;=0 and y=0: *True negatives* (TN)\n- &#375;=1 and y=0: *False positives* (FP)\n- &#375;=0 and y=1: *False negatives* (FN)\n- &#375;=",
    "summary": "The first step in calculating evaluation metrics for a binary classification model is usually to create a matrix of the number of correct and incorrect predictions for each possible class label:\n\n![Di...",
    "keywords": [
      "diagonal",
      "such",
      "color-intensity",
      "prediction",
      "first",
      "model",
      "where",
      "bottom-right",
      "evaluation",
      "true",
      "totals",
      "used",
      "well",
      "step",
      "often",
      "false",
      "negatives",
      "indicate",
      "each",
      "called"
    ]
  },
  {
    "id": 32,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Accuracy",
    "content": "The simplest metric you can calculate from the confusion matrix is *accuracy* - the proportion of predictions that the model got right. Accuracy is calculated as:\n\n***(TN+TP) &#247; (TN+FN+FP+TP)***\n\nIn the case of our diabetes example, the calculation is:\n\n(2+3) &#247; (2+1+0+3)\n\n= 5 &#247; 6\n\n= **0.83**\n\nSo for our validation data, the diabetes classification model produced correct predictions 83% of the time.\n\nAccuracy might initially seem like a good metric to evaluate a model, but consider ",
    "summary": "The simplest metric you can calculate from the confusion matrix is *accuracy* - the proportion of predictions that the model got right. Accuracy is calculated as:\n\n***(TN+TP) &#247; (TN+FN+FP+TP)***...",
    "keywords": [
      "example",
      "makes",
      "even",
      "simplest",
      "achieve",
      "consider",
      "calculate",
      "case",
      "negative",
      "differentiate",
      "understanding",
      "what",
      "between",
      "model",
      "like",
      "their",
      "population",
      "evaluate",
      "performs",
      "patients"
    ]
  },
  {
    "id": 33,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Recall",
    "content": "*Recall* is a metric that measures the proportion of positive cases that the model identified correctly. In other words, compared to the number of patients who *have* diabetes, how many did the model *predict* to have diabetes?\n\nThe formula for recall is:\n\n***TP &#247; (TP+FN)***\n\nFor our diabetes example:\n\n3 &#247; (3+1)\n\n= 3 &#247; 4\n\n= **0.75**\n\nSo our model correctly identified 75% of patients who have diabetes as having diabetes.",
    "summary": "*Recall* is a metric that measures the proportion of positive cases that the model identified correctly. In other words, compared to the number of patients who *have* diabetes, how many did the model...",
    "keywords": [
      "having",
      "example",
      "model",
      "compared",
      "patients",
      "formula",
      "proportion",
      "words",
      "cases",
      "number",
      "metric",
      "diabetes",
      "identified",
      "many",
      "positive",
      "other",
      "measures",
      "predict",
      "recall",
      "correctly"
    ]
  },
  {
    "id": 34,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Precision",
    "content": "*Precision* is a similar metric to recall, but measures the proportion of predicted positive cases where the true label is actually positive. In other words, what proportion of the patients *predicted* by the model to have diabetes actually *have* diabetes?\n\nThe formula for precision is:\n\n***TP &#247; (TP+FP)***\n\nFor our diabetes example:\n\n3 &#247; (3+0)\n\n= 3 &#247; 3\n\n= **1.0**\n\nSo 100% of the patients predicted by our model to have diabetes do in fact have diabetes.",
    "summary": "*Precision* is a similar metric to recall, but measures the proportion of predicted positive cases where the true label is actually positive. In other words, what proportion of the patients *predicted...",
    "keywords": [
      "example",
      "predicted",
      "similar",
      "what",
      "model",
      "where",
      "true",
      "actually",
      "patients",
      "proportion",
      "formula",
      "words",
      "cases",
      "metric",
      "fact",
      "diabetes",
      "positive",
      "other",
      "label",
      "measures"
    ]
  },
  {
    "id": 35,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "F1-score",
    "content": "*F1-score* is an overall metric that combines recall and precision. The formula for F1-score is:\n\n***(2 x Precision x Recall) &#247; (Precision + Recall)***\n\nFor our diabetes example:\n\n(2 x 1.0 x 0.75) &#247; (1.0 + 0.75)\n\n= 1.5 &#247; 1.75\n\n**= 0.86**",
    "summary": "*F1-score* is an overall metric that combines recall and precision. The formula for F1-score is:\n\n***(2 x Precision x Recall) &#247; (Precision + Recall)***\n\nFor our diabetes example:\n\n(2 x 1.0 x 0.75...",
    "keywords": [
      "precision",
      "example",
      "metric",
      "combines",
      "diabetes",
      "recall",
      "formula",
      "overall",
      "f1-score"
    ]
  },
  {
    "id": 36,
    "category": "Machine Learning",
    "file": "04-binary-classification.md",
    "heading": "Area Under the Curve (AUC)",
    "content": "Another name for recall is the *true positive rate* (TPR), and there's an equivalent metric called the *false positive rate* (FPR) that is calculated as **FP&#247;(FP+TN)**. We already know that the TPR for our model when using a threshold of 0.5 is 0.75, and we can use the formula for FPR to calculate a value of 0&#247;2 = 0.\n\nOf course, if we were to change the threshold above which the model predicts *true* (**1**), it would affect the number of positive and negative predictions; and therefor",
    "summary": "Another name for recall is the *true positive rate* (TPR), and there's an equivalent metric called the *false positive rate* (FPR) that is calculated as **FP&#247;(FP+TN)**. We already know that the T...",
    "keywords": [
      "meaning",
      "course",
      "higher",
      "between",
      "labels",
      "patient",
      "evaluate",
      "contrast",
      "axis",
      "there",
      "value",
      "threshold",
      "another",
      "calculated",
      "possible",
      "label",
      "roc-chart",
      "producing",
      "than",
      "using"
    ]
  },
  {
    "id": 37,
    "category": "Machine Learning",
    "file": "05-multiclass-classification.md",
    "heading": "Example - multiclass classification",
    "content": "Multiclass classification algorithms are used to calculate probability values for multiple class labels, enabling a model to predict the *most probable* class for a given observation.\n\nLet's explore an example in which we have some observations of penguins, in which the flipper length (***x***) of each penguin is recorded. For each observation, the data includes the penguin species (***y***), which is encoded as follows:\n\n- 0: Adelie\n- 1: Gentoo\n- 2: Chinstrap\n\n\n\n|![Diagram of a measuring ruler.",
    "summary": "Multiclass classification algorithms are used to calculate probability values for multiple class labels, enabling a model to predict the *most probable* class for a given observation.\n\nLet's explore a...",
    "keywords": [
      "example",
      "values",
      "multiple",
      "observation",
      "measuring",
      "calculate",
      "three",
      "flipper",
      "some",
      "enabling",
      "model",
      "labels",
      "observations",
      "used",
      "includes",
      "encoded",
      "adelie",
      "explore",
      "probability",
      "which"
    ]
  },
  {
    "id": 38,
    "category": "Machine Learning",
    "file": "05-multiclass-classification.md",
    "heading": "Training a multiclass classification model",
    "content": "To train a multiclass classification model, we need to use an algorithm to fit the training data to a function that calculates a probability value for each possible class. There are two kinds of algorithm you can use to do this:\n\n- One-vs-Rest (OvR) algorithms\n- Multinomial algorithms",
    "summary": "To train a multiclass classification model, we need to use an algorithm to fit the training data to a function that calculates a probability value for each possible class. There are two kinds of algor...",
    "keywords": [
      "one-vs-rest",
      "model",
      "calculates",
      "probability",
      "each",
      "data",
      "classification",
      "algorithm",
      "there",
      "value",
      "need",
      "kinds",
      "algorithms",
      "possible",
      "train",
      "function",
      "multiclass",
      "training",
      "class",
      "multinomial"
    ]
  },
  {
    "id": 39,
    "category": "Machine Learning",
    "file": "05-multiclass-classification.md",
    "heading": "One-vs-Rest (OvR) algorithms",
    "content": "One-vs-Rest algorithms train a binary classification function for each class, each calculating the probability that the observation is an example of the target class. Each function calculates the probability of the observation being a specific class compared to *any* other class. For our penguin species classification model, the algorithm would essentially create three binary classification functions:\n\n- ***f<sup>0</sup>(x) = P(y=0 | x)***\n- ***f<sup>1</sup>(x) = P(y=1 | x)***\n- ***f<sup>2</sup>",
    "summary": "One-vs-Rest algorithms train a binary classification function for each class, each calculating the probability that the observation is an example of the target class. Each function calculates the prob...",
    "keywords": [
      "example",
      "one-vs-rest",
      "observation",
      "three",
      "between",
      "model",
      "highest",
      "calculates",
      "probability",
      "compared",
      "each",
      "sigmoid",
      "kind",
      "penguin",
      "target",
      "classification",
      "algorithm",
      "functions",
      "value",
      "specific"
    ]
  },
  {
    "id": 40,
    "category": "Machine Learning",
    "file": "05-multiclass-classification.md",
    "heading": "Multinomial algorithms",
    "content": "As an alternative approach is to use a multinomial algorithm, which creates a single function that returns a multi-valued output. The output is a *vector* (an array of values) that contains the *probability distribution* for all possible classes - with a probability score for each class which when totaled add up to 1.0:\n\n***f(x) =[P(y=0|x), P(y=1|x), P(y=2|x)]***\n\nAn example of this kind of function is a *softmax* function, which could produce an output like the following example:\n\n[0.2, 0.3, 0.",
    "summary": "As an alternative approach is to use a multinomial algorithm, which creates a single function that returns a multi-valued output. The output is a *vector* (an array of values) that contains the *proba...",
    "keywords": [
      "classes",
      "example",
      "probabilities",
      "regardless",
      "values",
      "following",
      "when",
      "returns",
      "case",
      "represent",
      "resulting",
      "highest",
      "softmax",
      "model",
      "like",
      "used",
      "alternative",
      "array",
      "totaled",
      "vector"
    ]
  },
  {
    "id": 41,
    "category": "Machine Learning",
    "file": "05-multiclass-classification.md",
    "heading": "Evaluating a multiclass classification model",
    "content": "You can evaluate a multiclass classifier by calculating binary classification metrics for each individual class. Alternatively, you can calculate aggregate metrics that take all classes into account.\n\nLet's assume that we've validated our multiclass classifier, and obtained the following results:\n\n|Flipper length (x) | Actual species (y)| Predicted species (&#375;)|\n|---|---|--|\n|165|0|0|\n|171|0|0|\n|205|2|1|\n|195|1|1|\n|183|1|1|\n|221|2|2|\n|214|2|2|\n\nThe confusion matrix for a multiclass classifie",
    "summary": "You can evaluate a multiclass classifier by calculating binary classification metrics for each individual class. Alternatively, you can calculate aggregate metrics that take all classes into account....",
    "keywords": [
      "classes",
      "results",
      "individual",
      "following",
      "predicted",
      "calculate",
      "similar",
      "flipper",
      "negative",
      "take",
      "into",
      "account",
      "model",
      "combination",
      "labels",
      "true",
      "obtained",
      "false",
      "evaluate",
      "86x0"
    ]
  },
  {
    "id": 42,
    "category": "Machine Learning",
    "file": "06-clustering.md",
    "heading": "Example - clustering",
    "content": "For example, suppose a botanist observes a sample of flowers and records the number of leaves and petals on each flower:\n\n![Diagram of some flowers.](../media/flowers.png)\n\nThere are no known *labels* in the dataset, just two *features*. The goal is not to identify the different types (species) of flower; just to group similar flowers together based on the number of leaves and petals.\n\n|Leaves *(x<sub>1</sub>)*| Petals *(x<sub>2</sub>)*|\n|-|-|\n|0|5|\n|0|6|\n|1|3|\n|1|3|\n|1|6|\n|1|8|\n|2|3|\n|2|7|\n|2|8",
    "summary": "For example, suppose a botanist observes a sample of flowers and records the number of leaves and petals on each flower:\n\n![Diagram of some flowers.](../media/flowers.png)\n\nThere are no known *labels*...",
    "keywords": [
      "together",
      "example",
      "types",
      "flower",
      "similar",
      "petals",
      "leaves",
      "sample",
      "some",
      "group",
      "labels",
      "known",
      "botanist",
      "each",
      "clustering",
      "dataset",
      "based",
      "media",
      "number",
      "features"
    ]
  },
  {
    "id": 43,
    "category": "Machine Learning",
    "file": "06-clustering.md",
    "heading": "Training a clustering model",
    "content": "There are multiple algorithms you can use for clustering. One of the most commonly used algorithms is *K-Means* clustering, which consists of the following steps:\n\n1. The feature (***x***) values are vectorized to define *n*-dimensional coordinates (where *n* is the number of features). In the flower example, we have two features: number of leaves (***x<sub>1</sub>***) and number of petals (***x<sub>2</sub>***). So, the feature vector has two coordinates that we can use to conceptually plot the ",
    "summary": "There are multiple algorithms you can use for clustering. One of the most commonly used algorithms is *K-Means* clustering, which consists of the following steps:\n\n1. The feature (***x***) values are...",
    "keywords": [
      "feature",
      "maximum",
      "nearest",
      "center",
      "petals",
      "closest",
      "call",
      "between",
      "distance",
      "consists",
      "decide",
      "each",
      "repeated",
      "centroid",
      "define",
      "commonly",
      "centroids",
      "features",
      "there",
      "value"
    ]
  },
  {
    "id": 44,
    "category": "Machine Learning",
    "file": "06-clustering.md",
    "heading": "Evaluating a clustering model",
    "content": "Since there's no known label with which to compare the predicted cluster assignments, evaluation of a clustering model is based on how well the resulting clusters are separated from one another.\n\nThere are multiple metrics that you can use to evaluate cluster separation, including:\n\n- **Average distance to cluster center**: How close, on average, each point in the cluster is to the centroid of the cluster.\n- **Average distance to other center**: How close, on average, each point in the cluster i",
    "summary": "Since there's no known label with which to compare the predicted cluster assignments, evaluation of a clustering model is based on how well the resulting clusters are separated from one another.\n\nTher...",
    "keywords": [
      "maximum",
      "since",
      "compare",
      "multiple",
      "better",
      "predicted",
      "center",
      "resulting",
      "point",
      "between",
      "model",
      "well",
      "evaluation",
      "furthest",
      "close",
      "distance",
      "evaluate",
      "known",
      "which",
      "each"
    ]
  },
  {
    "id": 45,
    "category": "Machine Learning",
    "file": "07-deep-learning.md",
    "heading": "Example - Using deep learning for classification",
    "content": "To better understand how a deep neural network model works, let's explore an example in which a neural network is used to define a classification model for penguin species.\n\n![Diagram of a neural network used to classify a penguin species.](../media/deep-classification.png)\n\nThe feature data (***x***) consists of some measurements of a penguin. Specifically, the measurements are:\n\n- The length of the penguin's bill.\n- The depth of the penguin's bill.\n- The length of the penguin's flippers.\n- The",
    "summary": "To better understand how a deep neural network model works, let's explore an example in which a neural network is used to define a classification model for penguin species.\n\n![Diagram of a neural netw...",
    "keywords": [
      "feature",
      "machine",
      "next",
      "neural",
      "architecture",
      "meets",
      "highest",
      "bill",
      "problem",
      "mathematically",
      "adelie",
      "consists",
      "four",
      "sometimes",
      "flippers",
      "each",
      "define",
      "penguin",
      "there",
      "value"
    ]
  },
  {
    "id": 46,
    "category": "Machine Learning",
    "file": "07-deep-learning.md",
    "heading": "How does a neural network learn?",
    "content": "The weights in a neural network are central to how it calculates predicted values for labels. During the training process, the model *learns* the weights that will result in the most accurate predictions. Let's explore the training process in a little more detail to understand how this learning takes place.\n\n![Diagram of a neural network being trained, evaluated, and optimized.](../media/neural-network-training.png)\n\n1. The training and validation datasets are defined, and the training features ",
    "summary": "The weights in a neural network are central to how it calculates predicted values for labels. During the training process, the model *learns* the weights that will result in the most accurate predicti...",
    "keywords": [
      "optimized",
      "takes",
      "replacing",
      "neural",
      "between",
      "labels",
      "accurate",
      "calculates",
      "evaluate",
      "known",
      "acceptably",
      "each",
      "detail",
      "repeated",
      "involves",
      "penguin",
      "entire",
      "usually",
      "features",
      "value"
    ]
  },
  {
    "id": 47,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Common speech recognition scenarios",
    "content": "Speech recognition, also called speech-to-text, listens to audio input and transcribes it into written text. This capability powers a wide range of business and consumer applications.",
    "summary": "Speech recognition, also called speech-to-text, listens to audio input and transcribes it into written text. This capability powers a wide range of business and consumer applications.",
    "keywords": [
      "audio",
      "written",
      "wide",
      "into",
      "applications",
      "scenarios",
      "capability",
      "called",
      "text",
      "consumer",
      "business",
      "range",
      "recognition",
      "powers",
      "listens",
      "common",
      "speech-to-text",
      "transcribes",
      "speech",
      "input"
    ]
  },
  {
    "id": 48,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Customer service and support",
    "content": "Service centers use speech recognition to:\n\n- Transcribe customer calls in real time for agent reference and quality assurance.\n- Route callers to the right department based on what they say.\n- Analyze call sentiment and identify common customer issues.\n- Generate searchable call records for compliance and training.\n\n**Business value**: Reduces manual note-taking, improves response accuracy, and captures insights that improve service quality.",
    "summary": "Service centers use speech recognition to:\n\n- Transcribe customer calls in real time for agent reference and quality assurance.\n- Route callers to the right department based on what they say.\n- Analyz...",
    "keywords": [
      "response",
      "analyze",
      "searchable",
      "call",
      "route",
      "calls",
      "what",
      "transcribe",
      "assurance",
      "reduces",
      "note-taking",
      "improves",
      "callers",
      "quality",
      "based",
      "right",
      "department",
      "business",
      "captures",
      "reference"
    ]
  },
  {
    "id": 49,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Voice-activated assistants and agents",
    "content": "Virtual assistants and AI agents rely on speech recognition to:\n\n- Accept voice commands for hands-free control of devices and applications.\n- Answer questions using natural language understanding.\n- Complete tasks like setting reminders, sending messages, or searching information.\n- Control smart home devices, automotive systems, and wearable technology.\n\n**Business value**: Increases user engagement, simplifies complex workflows, and enables operation in situations where screens aren't practic",
    "summary": "Virtual assistants and AI agents rely on speech recognition to:\n\n- Accept voice commands for hands-free control of devices and applications.\n- Answer questions using natural language understanding.\n-...",
    "keywords": [
      "home",
      "increases",
      "accept",
      "voice-activated",
      "reminders",
      "questions",
      "automotive",
      "understanding",
      "messages",
      "information",
      "smart",
      "systems",
      "natural",
      "simplifies",
      "where",
      "like",
      "voice",
      "hands-free",
      "complex",
      "devices"
    ]
  },
  {
    "id": 50,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Meeting and interview transcription",
    "content": "Organizations transcribe conversations to:\n\n- Create searchable meeting notes and action item lists.\n- Provide real-time captions for participants who are deaf or hard of hearing.\n- Generate summaries of interviews, focus groups, and research sessions.\n- Extract key discussion points for documentation and follow-up.\n\n**Business value**: Saves hours of manual transcription work, ensures accurate records, and makes spoken content accessible to everyone.",
    "summary": "Organizations transcribe conversations to:\n\n- Create searchable meeting notes and action item lists.\n- Provide real-time captions for participants who are deaf or hard of hearing.\n- Generate summaries...",
    "keywords": [
      "work",
      "participants",
      "makes",
      "content",
      "groups",
      "hours",
      "notes",
      "searchable",
      "research",
      "interview",
      "deaf",
      "documentation",
      "transcribe",
      "accurate",
      "accessible",
      "interviews",
      "spoken",
      "ensures",
      "everyone",
      "real-time"
    ]
  },
  {
    "id": 51,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Healthcare documentation",
    "content": "Clinical professionals use speech recognition to:\n\n- Dictate patient notes directly into electronic health records.\n- Update treatment plans without interrupting patient care.\n- Reduce administrative burden and prevent physician burnout.\n- Improve documentation accuracy by capturing details in the moment.\n\n**Business value**: Increases time available for patient care, improves record completeness, and reduces documentation errors.",
    "summary": "Clinical professionals use speech recognition to:\n\n- Dictate patient notes directly into electronic health records.\n- Update treatment plans without interrupting patient care.\n- Reduce administrative...",
    "keywords": [
      "record",
      "clinical",
      "increases",
      "reduce",
      "notes",
      "into",
      "documentation",
      "healthcare",
      "without",
      "completeness",
      "patient",
      "reduces",
      "dictate",
      "improves",
      "care",
      "directly",
      "prevent",
      "update",
      "capturing",
      "errors"
    ]
  },
  {
    "id": 52,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Common speech synthesis scenarios",
    "content": "Speech synthesis, also called text-to-speech, converts written text into spoken audio. This technology creates voices for applications that need to communicate information audibly.",
    "summary": "Speech synthesis, also called text-to-speech, converts written text into spoken audio. This technology creates voices for applications that need to communicate information audibly.",
    "keywords": [
      "audio",
      "written",
      "into",
      "text-to-speech",
      "information",
      "spoken",
      "applications",
      "creates",
      "scenarios",
      "voices",
      "called",
      "text",
      "communicate",
      "audibly",
      "need",
      "converts",
      "technology",
      "common",
      "speech",
      "synthesis"
    ]
  },
  {
    "id": 53,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Conversational AI and chatbots",
    "content": "AI agents use speech synthesis to:\n\n- Respond to users with natural-sounding voices instead of requiring them to read text.\n- Create personalized interactions by adjusting tone, pace, and speaking style.\n- Handle customer inquiries through voice channels like phone systems.\n- Provide consistent brand experiences across voice and text interfaces.\n\n**Business value**: Makes AI agents more approachable, reduces customer effort, and extends service availability to voice-only channels.",
    "summary": "AI agents use speech synthesis to:\n\n- Respond to users with natural-sounding voices instead of requiring them to read text.\n- Create personalized interactions by adjusting tone, pace, and speaking sty...",
    "keywords": [
      "read",
      "consistent",
      "makes",
      "conversational",
      "them",
      "pace",
      "effort",
      "extends",
      "across",
      "style",
      "systems",
      "personalized",
      "reduces",
      "like",
      "voice",
      "brand",
      "inquiries",
      "voice-only",
      "voices",
      "adjusting"
    ]
  },
  {
    "id": 54,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Accessibility and content consumption",
    "content": "Applications generate audio to:\n\n- Read web content, articles, and documents aloud for users with visual impairments.\n- Support users with reading disabilities like dyslexia.\n- Enable content consumption while driving, exercising, or performing other tasks.\n- Provide audio alternatives for text-heavy interfaces.\n\n**Business value**: Expands your audience reach, demonstrates commitment to inclusion, and improves user satisfaction.",
    "summary": "Applications generate audio to:\n\n- Read web content, articles, and documents aloud for users with visual impairments.\n- Support users with reading disabilities like dyslexia.\n- Enable content consumpt...",
    "keywords": [
      "accessibility",
      "read",
      "audio",
      "performing",
      "content",
      "impairments",
      "documents",
      "enable",
      "expands",
      "dyslexia",
      "text-heavy",
      "alternatives",
      "demonstrates",
      "reading",
      "like",
      "visual",
      "improves",
      "applications",
      "satisfaction",
      "interfaces"
    ]
  },
  {
    "id": 55,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Notifications and alerts",
    "content": "Systems use speech synthesis to:\n\n- Announce important alerts, reminders, and status updates.\n- Provide navigation instructions in mapping and GPS applications.\n- Deliver time-sensitive information without requiring users to look at screens.\n- Communicate system status in industrial and operational environments.\n\n**Business value**: Ensures critical information reaches users even when visual attention isn't available, improving safety and responsiveness.",
    "summary": "Systems use speech synthesis to:\n\n- Announce important alerts, reminders, and status updates.\n- Provide navigation instructions in mapping and GPS applications.\n- Deliver time-sensitive information wi...",
    "keywords": [
      "alerts",
      "mapping",
      "time-sensitive",
      "navigation",
      "look",
      "important",
      "reaches",
      "even",
      "reminders",
      "when",
      "information",
      "systems",
      "without",
      "operational",
      "attention",
      "visual",
      "applications",
      "ensures",
      "requiring",
      "communicate"
    ]
  },
  {
    "id": 56,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "E-learning and training",
    "content": "Educational platforms use speech synthesis to:\n\n- Create narrated lessons and course content without recording studios.\n- Provide pronunciation examples for language learning.\n- Generate audio versions of written materials for different learning preferences.\n- Scale content production across multiple languages.\n\n**Business value**: Reduces content creation costs, supports diverse learning styles, and accelerates course development timelines.",
    "summary": "Educational platforms use speech synthesis to:\n\n- Create narrated lessons and course content without recording studios.\n- Provide pronunciation examples for language learning.\n- Generate audio version...",
    "keywords": [
      "audio",
      "content",
      "pronunciation",
      "multiple",
      "written",
      "course",
      "across",
      "without",
      "reduces",
      "e-learning",
      "scale",
      "supports",
      "narrated",
      "examples",
      "preferences",
      "recording",
      "timelines",
      "learning",
      "lessons",
      "studios"
    ]
  },
  {
    "id": 57,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Entertainment and media",
    "content": "Content creators use speech synthesis to:\n\n- Generate character voices for games and interactive experiences.\n- Produce podcast drafts and audiobook prototypes.\n- Create voiceovers for videos and presentations.\n- Personalize audio content based on user preferences.\n\n**Business value**: Lowers production costs, enables rapid prototyping, and creates customized experiences at scale.",
    "summary": "Content creators use speech synthesis to:\n\n- Generate character voices for games and interactive experiences.\n- Produce podcast drafts and audiobook prototypes.\n- Create voiceovers for videos and pres...",
    "keywords": [
      "audio",
      "content",
      "creators",
      "entertainment",
      "prototyping",
      "voiceovers",
      "scale",
      "drafts",
      "personalize",
      "voices",
      "creates",
      "preferences",
      "interactive",
      "audiobook",
      "games",
      "based",
      "media",
      "prototypes",
      "experiences",
      "podcast"
    ]
  },
  {
    "id": 58,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Combining speech recognition and synthesis",
    "content": "The most powerful speech-enabled applications combine both capabilities to create conversational experiences:\n\n- **Voice-driven customer service**: Agents listen to customer questions (recognition), process the request, and respond with helpful answers (synthesis).\n- **Interactive voice response (IVR) systems**: Callers speak their needs, and the system guides them through options using natural dialogue.\n- **Language learning applications**: Students speak practice phrases (recognition), and the",
    "summary": "The most powerful speech-enabled applications combine both capabilities to create conversational experiences:\n\n- **Voice-driven customer service**: Agents listen to customer questions (recognition), p...",
    "keywords": [
      "voice-driven",
      "options",
      "conversational",
      "them",
      "reduce",
      "response",
      "questions",
      "request",
      "systems",
      "natural",
      "powerful",
      "speak",
      "voice",
      "both",
      "feedback",
      "hands-free",
      "process",
      "fluid",
      "two-way",
      "applications"
    ]
  },
  {
    "id": 59,
    "category": "Speech",
    "file": "01-speech-solutions.md",
    "heading": "Key considerations before implementing speech",
    "content": "Before you add speech capabilities to your application, evaluate these factors:\n\n- **Audio quality requirements**: Background noise, microphone quality, and network bandwidth affect speech recognition accuracy.\n- **Language and dialect support**: Verify that your target languages and regional variations are supported.\n- **Privacy and compliance**: Understand how audio data is processed, stored, and protected to meet regulatory requirements.\n- **Latency expectations**: Real-time conversations req",
    "summary": "Before you add speech capabilities to your application, evaluate these factors:\n\n- **Audio quality requirements**: Background noise, microphone quality, and network bandwidth affect speech recognition...",
    "keywords": [
      "require",
      "requirements",
      "audio",
      "microphone",
      "accessibility",
      "standards",
      "implementation",
      "background",
      "wcag",
      "important",
      "even",
      "regulatory",
      "when",
      "bandwidth",
      "understand",
      "expectations",
      "meets",
      "some",
      "latency",
      "application"
    ]
  },
  {
    "id": 60,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Audio capture: Convert analog audio to digital",
    "content": "Speech recognition begins when a microphone converts sound waves into a digital signal. The system samples the analog audio thousands of times per second—typically 16,000 samples per second (16 kHz) for speech applications—and stores each measurement as a numeric value.\n\n![Diagram of an audio waveform.](../media/wave-form-spectogram.png)\n\n\n\nBefore moving to the next stage, the system often applies basic filters to remove hums, clicks, or other background noise that could confuse the model.",
    "summary": "Speech recognition begins when a microphone converts sound waves into a digital signal. The system samples the analog audio thousands of times per second—typically 16,000 samples per second (16 kHz) f...",
    "keywords": [
      "microphone",
      "audio",
      "background",
      "next",
      "numeric",
      "filters",
      "when",
      "analog",
      "stores",
      "second",
      "into",
      "wave-form-spectogram",
      "model",
      "signal",
      "begins",
      "waveform",
      "applications",
      "capture",
      "often",
      "before"
    ]
  },
  {
    "id": 61,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Pre-processing: Extract meaningful features",
    "content": "Raw audio samples contain too much information for efficient pattern recognition. Pre-processing transforms the waveform into a compact representation that highlights speech characteristics while discarding irrelevant details like absolute volume.",
    "summary": "Raw audio samples contain too much information for efficient pattern recognition. Pre-processing transforms the waveform into a compact representation that highlights speech characteristics while disc...",
    "keywords": [
      "volume",
      "audio",
      "much",
      "into",
      "irrelevant",
      "information",
      "absolute",
      "like",
      "waveform",
      "meaningful",
      "compact",
      "pattern",
      "samples",
      "characteristics",
      "contain",
      "features",
      "recognition",
      "transforms",
      "extract",
      "highlights"
    ]
  },
  {
    "id": 62,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Mel-Frequency Cepstral Coefficients (MFCCs)",
    "content": "MFCC is the most common feature extraction technique in speech recognition. It mimics how the human ear perceives sound by emphasizing frequencies where speech energy concentrates and compressing less important ranges.",
    "summary": "MFCC is the most common feature extraction technique in speech recognition. It mimics how the human ear perceives sound by emphasizing frequencies where speech energy concentrates and compressing less...",
    "keywords": [
      "feature",
      "technique",
      "important",
      "mfcc",
      "extraction",
      "compressing",
      "perceives",
      "where",
      "less",
      "mel-frequency",
      "most",
      "coefficients",
      "mfccs",
      "cepstral",
      "concentrates",
      "recognition",
      "emphasizing",
      "energy",
      "common",
      "human"
    ]
  },
  {
    "id": 63,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "How MFCC works:",
    "content": "1. **Divide audio into frames:** Split the signal into overlapping 20–30 millisecond windows.\n2. **Apply Fourier transform:** Convert each frame from time domain to frequency domain, revealing which pitches are present.\n3. **Map to Mel scale:** Adjust frequency bins to match human hearing sensitivity—we distinguish low pitches better than high ones.\n4. **Extract coefficients:** Compute a small set of numbers (often 13 coefficients) that summarize the spectral shape of each frame.\n\n![Diagram of a",
    "summary": "1. **Divide audio into frames:** Split the signal into overlapping 20–30 millisecond windows.\n2. **Apply Fourier transform:** Convert each frame from time domain to frequency domain, revealing which p...",
    "keywords": [
      "audio",
      "feature",
      "high",
      "present",
      "values",
      "mfcc",
      "fourier",
      "frame",
      "revealing",
      "adjust",
      "better",
      "storing",
      "representing",
      "time-frame",
      "into",
      "sample",
      "-113",
      "what",
      "numbers",
      "without"
    ]
  },
  {
    "id": 64,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Acoustic modeling: Recognize phonemes",
    "content": "Acoustic models learn the relationship between audio features and **phonemes**—the smallest units of sound that distinguish words. English uses about 44 phonemes; for example, the word \"cat\" comprises three phonemes: /k/, /æ/, and /t/.",
    "summary": "Acoustic models learn the relationship between audio features and **phonemes**—the smallest units of sound that distinguish words. English uses about 44 phonemes; for example, the word \"cat\" comprises...",
    "keywords": [
      "audio",
      "learn",
      "example",
      "three",
      "between",
      "smallest",
      "recognize",
      "distinguish",
      "units",
      "uses",
      "phonemes",
      "words",
      "features",
      "comprises",
      "english",
      "word",
      "models",
      "modeling",
      "acoustic",
      "relationship"
    ]
  },
  {
    "id": 65,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "From features to phonemes",
    "content": "Modern acoustic models use **transformer architectures**, a type of deep learning network that excels at sequence tasks. The transformer processes the MFCC feature vectors and predicts which phoneme is most likely at each moment in time.\n\nTransformer models achieve effective phoneme prediction through: \n\n- **Attention mechanism:** The model examines surrounding frames to resolve ambiguity. For example, the phoneme /t/ sounds different at the start of \"top\" versus the end of \"bat.\"\n- **Parallel p",
    "summary": "Modern acoustic models use **transformer architectures**, a type of deep learning network that excels at sequence tasks. The transformer processes the MFCC feature vectors and predicts which phoneme i...",
    "keywords": [
      "ambiguity",
      "feature",
      "audio",
      "example",
      "confidence",
      "speed",
      "mfcc",
      "versus",
      "multiple",
      "analyze",
      "achieve",
      "prediction",
      "sequences",
      "occur",
      "deep",
      "frame",
      "modern",
      "architectures",
      "unlike",
      "model"
    ]
  },
  {
    "id": 66,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Language modeling: Predict word sequences",
    "content": "Phoneme predictions alone don't guarantee accurate transcription. The acoustic model might confuse \"their\" and \"there\" because they share identical phonemes. Language models resolve ambiguity by applying knowledge of vocabulary, grammar, and common word patterns. Some ways in which the model guides word sequence prediction include:\n\n- **Statistical patterns:** The model knows \"The weather is nice\" appears more often in training data than \"The whether is nice.\"\n- **Context awareness:** After hear",
    "summary": "Phoneme predictions alone don't guarantee accurate transcription. The acoustic model might confuse \"their\" and \"there\" because they share identical phonemes. Language models resolve ambiguity by apply...",
    "keywords": [
      "ambiguity",
      "terminology",
      "medical",
      "sequences",
      "specialized",
      "prediction",
      "ways",
      "some",
      "knows",
      "improve",
      "context",
      "nice",
      "model",
      "whether",
      "grammar",
      "like",
      "accurate",
      "patterns",
      "sequence",
      "their"
    ]
  },
  {
    "id": 67,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Decoding: Select the best text hypothesis",
    "content": "Decoding algorithms search through millions of possible word sequences to find the transcription that best matches both acoustic and language model predictions. This stage balances two competing goals: staying faithful to the audio signal while producing readable, grammatically correct text.",
    "summary": "Decoding algorithms search through millions of possible word sequences to find the transcription that best matches both acoustic and language model predictions. This stage balances two competing goals...",
    "keywords": [
      "audio",
      "hypothesis",
      "sequences",
      "staying",
      "model",
      "both",
      "signal",
      "faithful",
      "matches",
      "grammatically",
      "select",
      "find",
      "text",
      "transcription",
      "stage",
      "correct",
      "best",
      "millions",
      "predictions",
      "algorithms"
    ]
  },
  {
    "id": 68,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Beam search decoding:",
    "content": "The most common technique, *beam search*, maintains a shortlist (the \"beam\") of top-scoring partial transcriptions as it processes each audio frame. At every step, it extends each hypothesis with the next most likely word, prunes low-scoring paths, and keeps only the best candidates.\n\nFor a three-second utterance, the decoder might evaluate thousands of hypotheses before selecting \"Please send the report by Friday\" over alternatives like \"Please sent the report buy Friday.\"\n\n> [!CAUTION]\n> Decod",
    "summary": "The most common technique, *beam search*, maintains a shortlist (the \"beam\") of top-scoring partial transcriptions as it processes each audio frame. At every step, it extends each hypothesis with the...",
    "keywords": [
      "sent",
      "audio",
      "technique",
      "beam",
      "utterance",
      "hypothesis",
      "next",
      "frame",
      "extends",
      "paths",
      "decoder",
      "candidates",
      "latency",
      "alternatives",
      "depth",
      "like",
      "friday",
      "intensive",
      "step",
      "applications"
    ]
  },
  {
    "id": 69,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Post-processing: Refine the output",
    "content": "The decoder produces raw text that often requires cleanup before presentation. Post-processing applies formatting rules and corrections to improve readability and accuracy.",
    "summary": "The decoder produces raw text that often requires cleanup before presentation. Post-processing applies formatting rules and corrections to improve readability and accuracy.",
    "keywords": [
      "improve",
      "cleanup",
      "refine",
      "presentation",
      "formatting",
      "often",
      "produces",
      "before",
      "post-processing",
      "corrections",
      "readability",
      "decoder",
      "accuracy",
      "text",
      "applies",
      "requires",
      "output",
      "rules"
    ]
  },
  {
    "id": 70,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "Common post-processing tasks:",
    "content": "- **Capitalization:** Convert \"hello my name is sam\" to \"Hello my name is Sam.\"\n- **Punctuation restoration:** Add periods, commas, and question marks based on prosody and grammar.\n- **Number formatting:** Change \"one thousand twenty three\" to \"1,023.\"\n- **Profanity filtering:** Mask or remove inappropriate words when required by policy.\n- **Inverse text normalization:** Convert spoken forms like \"three p m\" to \"3 PM.\"\n- **Confidence scoring:** Flag low-confidence words for human review in criti",
    "summary": "- **Capitalization:** Convert \"hello my name is sam\" to \"Hello my name is Sam.\"\n- **Punctuation restoration:** Add periods, commas, and question marks based on prosody and grammar.\n- **Number formatti...",
    "keywords": [
      "confidence",
      "highlight",
      "medical",
      "inappropriate",
      "along",
      "inverse",
      "name",
      "scores",
      "when",
      "returns",
      "thousand",
      "three",
      "filtering",
      "forms",
      "scoring",
      "change",
      "enabling",
      "application",
      "grammar"
    ]
  },
  {
    "id": 71,
    "category": "Speech",
    "file": "02-speech-recognition.md",
    "heading": "How the pipeline works together",
    "content": "Each stage builds on the previous one:\n\n1. **Audio capture** provides the raw signal.\n2. **Pre-processing** extracts MFCC features that highlight speech patterns.\n3. **Acoustic modeling** predicts phoneme probabilities using transformer networks.\n4. **Language modeling** applies vocabulary and grammar knowledge.\n5. **Decoding** searches for the best word sequence.\n6. **Post-processing** formats the text for human readers.\n\nBy separating concerns, modern speech recognition systems achieve high ac",
    "summary": "Each stage builds on the previous one:\n\n1. **Audio capture** provides the raw signal.\n2. **Pre-processing** extracts MFCC features that highlight speech patterns.\n3. **Acoustic modeling** predicts pho...",
    "keywords": [
      "together",
      "audio",
      "highlight",
      "probabilities",
      "high",
      "short",
      "overly",
      "mfcc",
      "concerns",
      "trace",
      "when",
      "achieve",
      "adjust",
      "conditions",
      "modern",
      "across",
      "systems",
      "model",
      "grammar",
      "transformer"
    ]
  },
  {
    "id": 72,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Text normalization: Standardize the text",
    "content": "Text normalization prepares raw text for pronunciation by expanding abbreviations, numbers, and symbols into spoken forms.\n\nConsider the sentence: \"*Dr. Smith ordered 3 items for $25.50 on 12/15/2023.*\"\n\nA normalization system converts it to: \"Doctor Smith ordered three items for twenty-five dollars and fifty cents on December fifteenth, two thousand twenty-three.\"\n\nCommon normalization tasks include:\n\n- Expanding abbreviations (\"Dr.\" becomes \"Doctor\", \"Inc.\" becomes \"Incorporated\")\n- Converting",
    "summary": "Text normalization prepares raw text for pronunciation by expanding abbreviations, numbers, and symbols into spoken forms.\n\nConsider the sentence: \"*Dr. Smith ordered 3 items for $25.50 on 12/15/2023....",
    "keywords": [
      "read",
      "ordered",
      "abbreviations",
      "present",
      "pronunciation",
      "fifteenth",
      "converting",
      "versus",
      "consider",
      "three",
      "thousand",
      "point",
      "zero",
      "into",
      "special",
      "context",
      "forms",
      "numbers",
      "handling",
      "attempting"
    ]
  },
  {
    "id": 73,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Linguistic analysis: Map text to phonemes",
    "content": "Linguistic analysis breaks normalized text into *phonemes* (the smallest units of sound) and determines how to pronounce each word. The linguistic analysis stage:\n\n1. Segments text into words and syllables.\n2. Looks up word pronunciations in lexicons (pronunciation dictionaries).\n3. Applies G2P rules or neural models to handle unknown words.\n4. Marks syllable boundaries and identifies stressed syllables.\n5. Determines phonetic context for adjacent sounds.",
    "summary": "Linguistic analysis breaks normalized text into *phonemes* (the smallest units of sound) and determines how to pronounce each word. The linguistic analysis stage:\n\n1. Segments text into words and syll...",
    "keywords": [
      "pronunciation",
      "lexicons",
      "neural",
      "into",
      "context",
      "determines",
      "looks",
      "smallest",
      "rules",
      "boundaries",
      "stressed",
      "units",
      "dictionaries",
      "phonetic",
      "handle",
      "each",
      "phonemes",
      "marks",
      "stage",
      "text"
    ]
  },
  {
    "id": 74,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Grapheme-to-phoneme conversion",
    "content": "Grapheme-to-phoneme (G2P) conversion maps written letters (*graphemes*) to pronunciation sounds (*phonemes*). English spelling doesn't reliably indicate pronunciation, so G2P systems use both rules and learned patterns.\n\nFor example:\n\n- The word \"though\" converts to /θoʊ/\n- The word \"through\" converts to /θruː/\n- The word \"cough\" converts to /kɔːf/\n\nEach word contains the letters \"ough\", but the pronunciation differs dramatically.\n\nModern G2P systems use neural networks trained on pronunciation ",
    "summary": "Grapheme-to-phoneme (G2P) conversion maps written letters (*graphemes*) to pronunciation sounds (*phonemes*). English spelling doesn't reliably indicate pronunciation, so G2P systems use both rules an...",
    "keywords": [
      "dramatically",
      "read",
      "learn",
      "example",
      "present",
      "pronunciation",
      "conversion",
      "differs",
      "versus",
      "when",
      "written",
      "grapheme-to-phoneme",
      "neural",
      "consider",
      "letters",
      "modern",
      "pronounced",
      "ough",
      "systems",
      "context"
    ]
  },
  {
    "id": 75,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Prosody generation: Determine pronunciation",
    "content": "Prosody refers to the rhythm, stress, and intonation patterns that make speech sound natural. Prosody generation determines **how** to say words, not just **which sounds** to produce.",
    "summary": "Prosody refers to the rhythm, stress, and intonation patterns that make speech sound natural. Prosody generation determines **how** to say words, not just **which sounds** to produce.",
    "keywords": [
      "pronunciation",
      "rhythm",
      "determines",
      "natural",
      "patterns",
      "intonation",
      "make",
      "determine",
      "which",
      "words",
      "generation",
      "prosody",
      "refers",
      "stress",
      "sounds",
      "produce",
      "sound",
      "speech",
      "just"
    ]
  },
  {
    "id": 76,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Elements of prosody",
    "content": "Prosody encompasses several vocal characteristics:\n\n- **Pitch contours**: Rising or falling pitch patterns that signal questions versus statements\n- **Duration**: How long to hold each sound, creating emphasis or natural rhythm\n- **Intensity**: Volume variations that highlight important words\n- **Pauses**: Breaks between phrases or sentences that aid comprehension\n- **Stress patterns**: Which syllables receive emphasis within words and sentences\n\nProsody has a significant effect on how spoken te",
    "summary": "Prosody encompasses several vocal characteristics:\n\n- **Pitch contours**: Rising or falling pitch patterns that signal questions versus statements\n- **Duration**: How long to hold each sound, creating...",
    "keywords": [
      "volume",
      "sentences",
      "highlight",
      "example",
      "meaning",
      "important",
      "said",
      "versus",
      "following",
      "consider",
      "cake",
      "questions",
      "changes",
      "rhythm",
      "statements",
      "several",
      "natural",
      "between",
      "interpreted",
      "patterns"
    ]
  },
  {
    "id": 77,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Transformer-based prosody prediction",
    "content": "Modern speech synthesis systems use transformer neural networks to predict prosody. Transformers excel at understanding context across entire sentences, not just adjacent words.",
    "summary": "Modern speech synthesis systems use transformer neural networks to predict prosody. Transformers excel at understanding context across entire sentences, not just adjacent words.",
    "keywords": [
      "sentences",
      "excel",
      "prediction",
      "neural",
      "modern",
      "across",
      "understanding",
      "context",
      "systems",
      "transformer",
      "networks",
      "words",
      "entire",
      "transformer-based",
      "adjacent",
      "prosody",
      "predict",
      "transformers",
      "speech",
      "synthesis"
    ]
  },
  {
    "id": 78,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "The prosody generation process:",
    "content": "1. **Input encoding**: The transformer receives the phoneme sequence with linguistic features (punctuation, part of speech, sentence structure)\n2. **Contextual analysis**: Self-attention mechanisms identify relationships between words (for example, which noun a pronoun references, where sentence boundaries fall)\n3. **Prosody prediction**: The model outputs predicted values for pitch, duration, and energy at each phoneme\n4. **Style factors**: The system considers speaking style (neutral, expressi",
    "summary": "1. **Input encoding**: The transformer receives the phoneme sequence with linguistic features (punctuation, part of speech, sentence structure)\n2. **Contextual analysis**: Self-attention mechanisms id...",
    "keywords": [
      "drop",
      "example",
      "conversational",
      "rise",
      "values",
      "hours",
      "predicted",
      "linguistic",
      "prediction",
      "part",
      "questions",
      "style",
      "mechanisms",
      "between",
      "where",
      "model",
      "transformer",
      "sequence",
      "boundaries",
      "neutral"
    ]
  },
  {
    "id": 79,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Factors influencing prosody choices:",
    "content": "- **Syntax**: Clause boundaries indicate where to pause\n- **Semantics**: Important concepts receive emphasis\n- **Discourse context**: Contrasting information or answers to questions may carry extra stress\n- **Speaker identity**: Each voice has characteristic pitch range and speaking rate\n- **Emotional tone**: Excitement, concern, or neutrality shape prosodic patterns\n\nThe prosody predictions create a target specification: \"Produce the phoneme /æ/ at 180 Hz for 80 milliseconds with moderate inten",
    "summary": "- **Syntax**: Clause boundaries indicate where to pause\n- **Semantics**: Important concepts receive emphasis\n- **Discourse context**: Contrasting information or answers to questions may carry extra st...",
    "keywords": [
      "dramatically",
      "results",
      "characteristic",
      "important",
      "semantics",
      "pronunciation",
      "neutrality",
      "identity",
      "questions",
      "specification",
      "context",
      "information",
      "pause",
      "where",
      "excitement",
      "concepts",
      "voice",
      "patterns",
      "affects",
      "contrasting"
    ]
  },
  {
    "id": 80,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Speech synthesis: Generate audio",
    "content": "Speech synthesis generates the final audio waveform based on the phoneme sequence and prosody specifications.",
    "summary": "Speech synthesis generates the final audio waveform based on the phoneme sequence and prosody specifications.",
    "keywords": [
      "sequence",
      "audio",
      "waveform",
      "generates",
      "phoneme",
      "generate",
      "specifications",
      "speech",
      "synthesis",
      "final",
      "based",
      "prosody"
    ]
  },
  {
    "id": 81,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "Waveform generation approaches",
    "content": "Modern systems use neural vocoders—deep learning models that generate audio samples directly. Popular vocoder architectures include WaveNet, WaveGlow, and HiFi-GAN.",
    "summary": "Modern systems use neural vocoders—deep learning models that generate audio samples directly. Popular vocoder architectures include WaveNet, WaveGlow, and HiFi-GAN.",
    "keywords": [
      "audio",
      "neural",
      "deep",
      "modern",
      "architectures",
      "approaches",
      "systems",
      "waveglow",
      "waveform",
      "directly",
      "learning",
      "vocoders",
      "hifi-gan",
      "generation",
      "samples",
      "include",
      "generate",
      "vocoder",
      "popular",
      "models"
    ]
  },
  {
    "id": 82,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "The synthesis process:",
    "content": "1. **Acoustic feature generation**: An acoustic model (often a transformer) converts phonemes and prosody targets into mel-spectrograms—visual representations of sound frequencies over time\n2. **Vocoding**: The neural vocoder converts mel-spectrograms into raw audio waveforms (sequences of amplitude values at 16,000-48,000 samples per second)\n3. **Post-processing**: The system applies filtering, normalization, or audio effects to match target output specifications\n\n\n\nThe vocoder essentially perf",
    "summary": "1. **Acoustic feature generation**: An acoustic model (often a transformer) converts phonemes and prosody targets into mel-spectrograms—visual representations of sound frequencies over time\n2. **Vocod...",
    "keywords": [
      "vocoding",
      "feature",
      "audio",
      "representations",
      "values",
      "inverse",
      "sequences",
      "neural",
      "linguistic",
      "second",
      "into",
      "filtering",
      "what",
      "model",
      "amplitude",
      "transformer",
      "automatic",
      "000-48",
      "process",
      "visual"
    ]
  },
  {
    "id": 83,
    "category": "Speech",
    "file": "03-speech-synthesis.md",
    "heading": "The complete pipeline in action",
    "content": "When you request speech synthesis for \"Dr. Chen's appointment is at 3:00 PM\":\n\n1. **Text normalization** expands it to \"Doctor Chen's appointment is at three o'clock P M\"\n2. **Linguistic analysis** converts it to phonemes: /ˈdɑktər ˈtʃɛnz əˈpɔɪntmənt ɪz æt θri əˈklɑk pi ɛm/\n3. **Prosody generation** predicts pitch rising slightly on \"appointment\", a pause after \"is\", and emphasis on \"three\"\n4. **Speech synthesis** generates an audio waveform matching those specifications\n\nThe entire process typi",
    "summary": "When you request speech synthesis for \"Dr. Chen's appointment is at 3:00 PM\":\n\n1. **Text normalization** expands it to \"Doctor Chen's appointment is at three o'clock P M\"\n2. **Linguistic analysis** co...",
    "keywords": [
      "audio",
      "when",
      "expands",
      "three",
      "request",
      "clock",
      "second",
      "modern",
      "pause",
      "waveform",
      "process",
      "emphasis",
      "action",
      "phonemes",
      "matching",
      "text",
      "rising",
      "slightly",
      "chen",
      "generation"
    ]
  },
  {
    "id": 84,
    "category": "Computer Vision",
    "file": "01-overview.md",
    "heading": "Image classification",
    "content": "One of the oldest computer vision solutions is a technique called *image classification*, in which a model that has been trained with a large number of images is used to predict a text label based on an image's contents.\n\nFor example, suppose a grocery store wants to implement smart checkout system that identifies produce automatically. For example, the customer could place fruits or vegetables on a scale at the checkout, and an AI application connected to a camera could automatically identify t",
    "summary": "One of the oldest computer vision solutions is a technique called *image classification*, in which a model that has been trained with a large number of images is used to predict a text label based on...",
    "keywords": [
      "work",
      "volume",
      "labeled",
      "technique",
      "example",
      "types",
      "charge",
      "photographs",
      "name",
      "wants",
      "subject",
      "images",
      "smart",
      "image-classification",
      "model",
      "application",
      "scale",
      "used",
      "amount",
      "appropriate"
    ]
  },
  {
    "id": 85,
    "category": "Computer Vision",
    "file": "01-overview.md",
    "heading": "Object detection",
    "content": "Suppose the grocery store wants a more sophisticated system, in which the checkout can scan multiple items on the checkout and identify each of them. A common approach to this type of problem is called \"object detection\". Object detection models examine multiple regions in an image to find individual objects and their locations. The resulting prediction from the model includes which objects were detected, and the specific regions of the image in which they appear - indicated by the coordinates o",
    "summary": "Suppose the grocery store wants a more sophisticated system, in which the checkout can scan multiple items on the checkout and identify each of them. A common approach to this type of problem is calle...",
    "keywords": [
      "them",
      "individual",
      "multiple",
      "photograph",
      "wants",
      "prediction",
      "coordinates",
      "resulting",
      "model",
      "bounding",
      "includes",
      "sophisticated",
      "grocery",
      "problem",
      "indicated",
      "their",
      "items",
      "objects",
      "regions",
      "which"
    ]
  },
  {
    "id": 86,
    "category": "Computer Vision",
    "file": "01-overview.md",
    "heading": "Semantic segmentation",
    "content": "Another, more sophisticated way to detect objects in an image, is called \"semantic segmentation\". In this approach, a model is trained to find objects, and classify individual pixels in the image based on the object to which they belong. The result of this process is a much more precise prediction of the location of objects in the image.\n\n![Photograph of an orange, apple, and banana with overlaid masks.](../media/semantic-segmentation.png)",
    "summary": "Another, more sophisticated way to detect objects in an image, is called \"semantic segmentation\". In this approach, a model is trained to find objects, and classify individual pixels in the image base...",
    "keywords": [
      "individual",
      "photograph",
      "prediction",
      "much",
      "model",
      "process",
      "sophisticated",
      "semantic",
      "semantic-segmentation",
      "objects",
      "which",
      "called",
      "apple",
      "find",
      "based",
      "media",
      "more",
      "location",
      "overlaid",
      "approach"
    ]
  },
  {
    "id": 87,
    "category": "Computer Vision",
    "file": "01-overview.md",
    "heading": "Contextual image analysis",
    "content": "The latest *multimodal* computer vision models are trained to find contextual relationships between objects in images and the text that describes them. The result is an ability to semantically interpret an image to determine what objects and activities it depicts; and generate appropriate descriptions or suggest relevant tags.\n\n![Photograph of a person eating an apple.](../media/image-analysis.png)\n\n***A person eating an apple.***",
    "summary": "The latest *multimodal* computer vision models are trained to find contextual relationships between objects in images and the text that describes them. The result is an ability to semantically interpr...",
    "keywords": [
      "eating",
      "them",
      "person",
      "photograph",
      "images",
      "image-analysis",
      "tags",
      "what",
      "between",
      "appropriate",
      "semantically",
      "latest",
      "objects",
      "vision",
      "computer",
      "determine",
      "apple",
      "find",
      "text",
      "depicts"
    ]
  },
  {
    "id": 88,
    "category": "Computer Vision",
    "file": "02-understand-image-processing.md",
    "heading": "Filters",
    "content": "A common way to perform image processing tasks is to apply *filters* that modify the pixel values of the image to create a visual effect. A filter is defined by one or more arrays of pixel values, called filter *kernels*. For example, you could define filter with a 3x3 kernel as shown in this example:\n\n```\n-1 -1 -1\n-1  8 -1\n-1 -1 -1\n```\n\nThe kernel is then *convolved* across the image, calculating a weighted sum for each 3x3 patch of pixels and assigning the result to a new image. It's easier to",
    "summary": "A common way to perform image processing tasks is to apply *filters* that modify the pixel values of the image to create a visual effect. A filter is defined by one or more arrays of pixel values, cal...",
    "keywords": [
      "perform",
      "move",
      "outside",
      "convolved",
      "patch",
      "start",
      "kernel",
      "original",
      "laplace",
      "corresponding",
      "because",
      "arrays",
      "each",
      "repeated",
      "define",
      "kind",
      "repeat",
      "right",
      "entire",
      "shape"
    ]
  },
  {
    "id": 89,
    "category": "Computer Vision",
    "file": "04-modern-vision-models.md",
    "heading": "Semantic modeling for language - Transformers",
    "content": "Transformers work by processing huge volumes of data, and encoding language *tokens* (representing individual words or phrases) as vector-based *embeddings* (arrays of numeric values). A technique called *attention* is used to assign embedding values that reflect different aspects of how each token is used in the context of other tokens. You can think of the embeddings as vectors in multidimensional space, in which each dimension embeds a linguistic attribute of a token based on its context in t",
    "summary": "Transformers work by processing huge volumes of data, and encoding language *tokens* (representing individual words or phrases) as vector-based *embeddings* (arrays of numeric values). A technique cal...",
    "keywords": [
      "work",
      "technique",
      "makes",
      "build",
      "vector-based",
      "individual",
      "values",
      "representing",
      "numeric",
      "translation",
      "space",
      "similar",
      "assign",
      "closely",
      "context",
      "between",
      "tokens",
      "media",
      "attention",
      "model"
    ]
  },
  {
    "id": 90,
    "category": "Computer Vision",
    "file": "04-modern-vision-models.md",
    "heading": "Semantic model for images - Vision transformers",
    "content": "The success of transformers as a way to build language models has led AI researchers to consider whether the same approach would be effective for image data. The result is the development of *vision transformer* (ViT) models, in which a model is trained using a large volume of images. Instead of encoding text-based tokens, the transformer extracts *patches* of pixel values from the image, and generates a linear vector from the pixel values.\n\n![Diagram of a photo with patches assigned to vectors.",
    "summary": "The success of transformers as a way to build language models has led AI researchers to consider whether the same approach would be effective for image data. The result is the development of *vision t...",
    "keywords": [
      "volume",
      "related",
      "images",
      "between",
      "attention",
      "semantic",
      "vectors",
      "because",
      "commonly",
      "contrast",
      "shape",
      "multidimensional",
      "features",
      "researchers",
      "common",
      "result",
      "language",
      "using",
      "development",
      "patches"
    ]
  },
  {
    "id": 91,
    "category": "Computer Vision",
    "file": "04-modern-vision-models.md",
    "heading": "Bringing it all together - Multimodal models",
    "content": "A language transformer creates embeddings that define a linguistic vocabulary that encode semantic relationships between words. A vision transformer creates a visual vocabulary that does the same for visual features. When the training data includes images with associated text descriptions, we can combine the encoders from both of these transformers in a *multimodal* model; and use a technique called *cross-model attention* to define a unified spatial representation of the embeddings, like this.\n",
    "summary": "A language transformer creates embeddings that define a linguistic vocabulary that encode semantic relationships between words. A vision transformer creates a visual vocabulary that does the same for...",
    "keywords": [
      "together",
      "technique",
      "bringing",
      "backpack",
      "previously",
      "combines",
      "park",
      "person",
      "when",
      "space",
      "photograph",
      "encode",
      "images",
      "recognizing",
      "multi-modal",
      "between",
      "model",
      "cross-model",
      "attention",
      "transformer"
    ]
  },
  {
    "id": 92,
    "category": "Information Extraction",
    "file": "01-introduction.md",
    "heading": "Financial document processing",
    "content": "**Invoice processing** solutions can analyze invoices to extract:\n\n- **Vendor information**: Company names, addresses, and contact details.\n- **Transaction details**: Invoice numbers, dates, and payment terms.\n- **Line items**: Product descriptions, quantities, unit prices, and totals.\n- **Tax information**: Tax rates, amounts, and exempt items.\n\n**Receipt processing** solutions might need to read receipts to extract:\n\n- **Merchant details**: Store names, locations, and transaction IDs.\n- **Purc",
    "summary": "**Invoice processing** solutions can analyze invoices to extract:\n\n- **Vendor information**: Company names, addresses, and contact details.\n- **Transaction details**: Invoice numbers, dates, and payme...",
    "keywords": [
      "read",
      "purchased",
      "loyalty",
      "expenses",
      "analyze",
      "merchant",
      "prices",
      "regulatory",
      "account",
      "information",
      "document",
      "numbers",
      "quantities",
      "change",
      "statements",
      "reporting",
      "totals",
      "methods",
      "addresses",
      "items"
    ]
  },
  {
    "id": 93,
    "category": "Information Extraction",
    "file": "01-introduction.md",
    "heading": "Legal and compliance documents",
    "content": "**Contract processing** solutions can be used to extract:\n\n- **Party information**: Contracting parties, signatories, and witnesses.\n- **Terms and conditions**: Effective dates, renewal terms, and termination clauses.\n- **Financial terms**: Payment schedules, penalties, and insurance requirements.\n\n**Regulatory forms** that may need to be processed include:\n\n- **Tax documents**: W-2s, 1099s, and other tax forms.\n- **Insurance forms**: Policy numbers, claim amounts, and incident details.\n- **Gove",
    "summary": "**Contract processing** solutions can be used to extract:\n\n- **Party information**: Contracting parties, signatories, and witnesses.\n- **Terms and conditions**: Effective dates, renewal terms, and ter...",
    "keywords": [
      "requirements",
      "renewal",
      "documents",
      "regulatory",
      "termination",
      "signatories",
      "claim",
      "party",
      "conditions",
      "penalties",
      "information",
      "forms",
      "numbers",
      "application",
      "used",
      "witnesses",
      "schedules",
      "government",
      "1099s",
      "payment"
    ]
  },
  {
    "id": 94,
    "category": "Information Extraction",
    "file": "01-introduction.md",
    "heading": "Healthcare documentation",
    "content": "**Medical records** can be processed to retrieve:\n\n- **Patient information**: Demographics, medical record numbers, and insurance details.\n- **Clinical data**: Diagnoses, treatments, medication lists, and vital signs.\n- **Administrative data**: Appointment schedules, billing codes, and provider information.",
    "summary": "**Medical records** can be processed to retrieve:\n\n- **Patient information**: Demographics, medical record numbers, and insurance details.\n- **Clinical data**: Diagnoses, treatments, medication lists,...",
    "keywords": [
      "record",
      "clinical",
      "medication",
      "signs",
      "medical",
      "provider",
      "diagnoses",
      "documentation",
      "information",
      "numbers",
      "healthcare",
      "treatments",
      "patient",
      "schedules",
      "data",
      "retrieve",
      "lists",
      "processed",
      "vital",
      "administrative"
    ]
  },
  {
    "id": 95,
    "category": "Information Extraction",
    "file": "01-introduction.md",
    "heading": "Supply chain and logistics",
    "content": "**Shipping documents** often contain vital details such as:\n\n- **Shipment details**: Tracking numbers, weights, and dimensions.\n- **Address information**: Sender and recipient details, and delivery instructions.\n- **Customs documentation**: Commodity codes, values, and country of origin.\n\n**Purchase Orders** are commonly processed to extract:\n\n- **Vendor information**: Supplier details and contact information.\n- **Product specifications**: Item codes, descriptions, and quantities.\n- **Delivery r",
    "summary": "**Shipping documents** often contain vital details such as:\n\n- **Shipment details**: Tracking numbers, weights, and dimensions.\n- **Address information**: Sender and recipient details, and delivery in...",
    "keywords": [
      "requirements",
      "such",
      "weights",
      "delivery",
      "values",
      "documents",
      "special",
      "documentation",
      "information",
      "sender",
      "numbers",
      "orders",
      "quantities",
      "systems",
      "schedules",
      "shipment",
      "often",
      "scenarios",
      "recipient",
      "item"
    ]
  },
  {
    "id": 96,
    "category": "Information Extraction",
    "file": "02-overview.md",
    "heading": "Choosing the right approach",
    "content": "When planning an information extraction solution, it's important to consider the requirements and constraints that the system must address. Some key considerations include:\n\n- **Document characteristics**. The documents from which you need to extract data are the basis of the whole solution. Consider factors like:\n    - **Layout consistency**: Standardized forms favor template-based approaches, while a need to process multiple formats and layouts may require a more complex machine learning based",
    "summary": "When planning an information extraction solution, it's important to consider the requirements and constraints that the system must address. Some key considerations include:\n\n- **Document characteristi...",
    "keywords": [
      "require",
      "requirements",
      "volume",
      "machine",
      "important",
      "optimized",
      "format",
      "forms",
      "document",
      "template-based",
      "protected",
      "choosing",
      "compatibility",
      "significant",
      "limit",
      "commonly",
      "right",
      "critical",
      "system",
      "workloads"
    ]
  },
  {
    "id": 97,
    "category": "Information Extraction",
    "file": "03-vision-extraction.md",
    "heading": "The OCR pipeline: A step-by-step process",
    "content": "The OCR pipeline consists of five essential stages that work together to transform visual information into text data.\n\n![Diagram of the OCR pipeline.](../media/optical-character-recognition.png)\n\nThe stages in the OCR process are:\n\n1. Image acquisition and input.\n1. Preprocessing and image enhancement.\n1. Text region detection.\n1. Character recognition and classification.\n1. Output generation and post-processing.\n\nLet's examine each stage in more depth.",
    "summary": "The OCR pipeline consists of five essential stages that work together to transform visual information into text data.\n\n![Diagram of the OCR pipeline.](../media/optical-character-recognition.png)\n\nThe...",
    "keywords": [
      "work",
      "together",
      "into",
      "information",
      "depth",
      "acquisition",
      "step-by-step",
      "process",
      "visual",
      "consists",
      "optical-character-recognition",
      "five",
      "each",
      "stage",
      "text",
      "region",
      "media",
      "data",
      "more",
      "generation"
    ]
  },
  {
    "id": 98,
    "category": "Information Extraction",
    "file": "03-vision-extraction.md",
    "heading": "Stage 1: Image acquisition and input",
    "content": "The pipeline begins when an image containing text enters the system. This could be:\n\n- A photograph taken with a smartphone camera.\n- A scanned document from a flatbed or document scanner.\n- A frame extracted from a video stream.\n- A PDF page rendered as an image.",
    "summary": "The pipeline begins when an image containing text enters the system. This could be:\n\n- A photograph taken with a smartphone camera.\n- A scanned document from a flatbed or document scanner.\n- A frame e...",
    "keywords": [
      "frame",
      "flatbed",
      "when",
      "photograph",
      "video",
      "document",
      "scanner",
      "acquisition",
      "begins",
      "smartphone",
      "rendered",
      "stage",
      "text",
      "extracted",
      "image",
      "containing",
      "pipeline",
      "enters",
      "system",
      "camera"
    ]
  },
  {
    "id": 99,
    "category": "Information Extraction",
    "file": "03-vision-extraction.md",
    "heading": "Stage 2: Preprocessing and image enhancement",
    "content": "Before text detection begins, the following techniques are used to optimize the image for better recognition accuracy:\n\n- **Noise reduction** removes visual artifacts, dust spots, and scanning imperfections that could interfere with text detection. The specific techniques used to perform noise reduction include:\n\n    - **Filtering and image processing algorithms**: Gaussian filters, median filters, and morphological operations.\n    - **Machine learning models**: Denoising autoencoders and convol",
    "summary": "Before text detection begins, the following techniques are used to optimize the image for better recognition accuracy:\n\n- **Noise reduction** removes visual artifacts, dust spots, and scanning imperfe...",
    "keywords": [
      "perform",
      "cleanup",
      "machine",
      "background",
      "neural",
      "operations",
      "images",
      "document",
      "between",
      "component",
      "corrects",
      "level",
      "text",
      "adjustment",
      "contrast",
      "skew",
      "noise",
      "features",
      "there",
      "character"
    ]
  },
  {
    "id": 100,
    "category": "Information Extraction",
    "file": "03-vision-extraction.md",
    "heading": "Stage 3: Text region detection",
    "content": "The system analyzes the preprocessed image to identify areas that contain text by using the following techniques:\n\n- **Layout analysis** distinguishes between text regions, images, graphics, and white space areas. Techniques for layout analysis include:\n\n    - **Traditional approaches**: Connected component analysis, run-length encoding, and projection-based segmentation.\n    - **Deep learning models**: Semantic segmentation networks like U-Net, Mask R-CNN, and specialized document layout analys",
    "summary": "The system analyzes the preprocessed image to identify areas that contain text by using the following techniques:\n\n- **Layout analysis** distinguishes between text regions, images, graphics, and white...",
    "keywords": [
      "machine",
      "neural",
      "operations",
      "images",
      "determined",
      "document",
      "between",
      "component",
      "graph-based",
      "sequence",
      "patterns",
      "semantic",
      "layoutlm",
      "text",
      "features",
      "headers",
      "system",
      "rule-based",
      "classifiers",
      "common"
    ]
  },
  {
    "id": 101,
    "category": "Information Extraction",
    "file": "03-vision-extraction.md",
    "heading": "Stage 4: Character recognition and classification",
    "content": "This is the core of the OCR process where individual characters are identified:\n\n- **Feature extraction**: Analyzes the shape, size, and distinctive characteristics of each character or symbol.\n    - **Traditional methods**: Statistical features like moments, Fourier descriptors, and structural features (loops, endpoints, intersections)\n    - **Deep learning approaches**: Convolutional neural networks that automatically learn discriminative features from raw pixel data\n\n- **Pattern matching**: C",
    "summary": "This is the core of the OCR process where individual characters are identified:\n\n- **Feature extraction**: Analyzes the shape, size, and distinctive characteristics of each character or symbol.\n    -...",
    "keywords": [
      "feature",
      "such",
      "multi-layer",
      "neural",
      "attention",
      "efficientnet",
      "perceptrons",
      "vectors",
      "distance",
      "hidden",
      "focus",
      "converted",
      "automatically",
      "neighbors",
      "each",
      "uses",
      "uncertainty",
      "parts",
      "shape",
      "identified"
    ]
  },
  {
    "id": 102,
    "category": "Information Extraction",
    "file": "03-vision-extraction.md",
    "heading": "Stage 5: Output generation and post-processing",
    "content": "The final stage converts recognition results into usable text data:\n\n- **Text compilation**: Assembles individual character recognitions into complete words and sentences.\n    - **Rule-based assembly**: Deterministic algorithms that combine character predictions using spatial proximity and confidence thresholds.\n    - **Sequence models**: Recurrent neural networks (RNNs) and Long Short-Term Memory (LSTM) networks that model text as sequential data.\n    - **Attention-based models**: Transformer a",
    "summary": "The final stage converts recognition results into usable text data:\n\n- **Text compilation**: Assembles individual character recognitions into complete words and sentences.\n    - **Rule-based assembly*...",
    "keywords": [
      "thresholds",
      "mapping",
      "format",
      "parsers",
      "neural",
      "coordinate",
      "multi-modal",
      "document",
      "between",
      "grammar",
      "sequence",
      "transformation",
      "original",
      "r-trees",
      "each",
      "layoutlm",
      "indexing",
      "text",
      "lists",
      "breaks"
    ]
  },
  {
    "id": 103,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "The field extraction pipeline",
    "content": "Field extraction follows a systematic pipeline that transforms OCR output into structured data.\n\n![Diagram of the field extraction pipeline.](../media/field-extraction.png)\n\nThe stages in the field extraction process are:\n\n1. OCR output ingestion.\n1. Field detection and candidate identification.\n1. Field mapping and association.\n1. Data normalization and standardization.\n1. Integration with business processes and systems.\n\nLet's explore these stages in more detail.",
    "summary": "Field extraction follows a systematic pipeline that transforms OCR output into structured data.\n\n![Diagram of the field extraction pipeline.](../media/field-extraction.png)\n\nThe stages in the field ex...",
    "keywords": [
      "structured",
      "mapping",
      "extraction",
      "standardization",
      "into",
      "systems",
      "field",
      "process",
      "identification",
      "explore",
      "detail",
      "media",
      "data",
      "systematic",
      "follows",
      "more",
      "association",
      "normalization",
      "business",
      "ingestion"
    ]
  },
  {
    "id": 104,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Stage 1: OCR output ingestion",
    "content": "The process begins with the structured output from the OCR pipeline, which can include:\n\n- **Raw text content**: The actual characters and words extracted from the document\n- **Positional metadata**: Bounding box coordinates, page locations, and reading order information\n- **Confidence scores**: OCR engine confidence levels for each text element\n- **Layout information**: Document structure, line breaks, paragraph boundaries",
    "summary": "The process begins with the structured output from the OCR pipeline, which can include:\n\n- **Raw text content**: The actual characters and words extracted from the document\n- **Positional metadata**:...",
    "keywords": [
      "structured",
      "confidence",
      "content",
      "scores",
      "coordinates",
      "information",
      "document",
      "reading",
      "bounding",
      "begins",
      "process",
      "which",
      "each",
      "stage",
      "actual",
      "text",
      "words",
      "line",
      "include",
      "breaks"
    ]
  },
  {
    "id": 105,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Stage 2: Field detection and candidate identification",
    "content": "This stage identifies potential field value in the OCR output. There are multiple approaches that can be used, independently or in combination, to determine the likely fields in the OCR results.",
    "summary": "This stage identifies potential field value in the OCR output. There are multiple approaches that can be used, independently or in combination, to determine the likely fields in the OCR results.",
    "keywords": [
      "results",
      "multiple",
      "approaches",
      "combination",
      "field",
      "used",
      "independently",
      "identification",
      "determine",
      "stage",
      "likely",
      "there",
      "value",
      "potential",
      "fields",
      "output",
      "identifies",
      "detection",
      "candidate"
    ]
  },
  {
    "id": 106,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Template-based detection",
    "content": "Templates for field detection rely on rule-based pattern matching. Field identification may be accomplished using techniques such as:\n\n- Predefined document layouts with known field positions and anchor keywords.\n- Searches for label-value pairs like \"Invoice Number:\", \"Date:\", \"Total:\".\n- Regular expressions and string matching algorithms.\n\n**Advantages** of a template-based approach include high accuracy for known document types, fast processing, and explainable results.\n\n**Limitations** of th",
    "summary": "Templates for field detection rely on rule-based pattern matching. Field identification may be accomplished using techniques such as:\n\n- Predefined document layouts with known field positions and anch...",
    "keywords": [
      "accomplished",
      "results",
      "such",
      "types",
      "high",
      "templates",
      "positions",
      "pairs",
      "limitations",
      "techniques",
      "document",
      "regular",
      "field",
      "like",
      "identification",
      "template-based",
      "requirement",
      "known",
      "string",
      "matching"
    ]
  },
  {
    "id": 107,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Machine learning-based detection",
    "content": "Instead of hard-coded logic to extract fields based on known names and locations, you can use a corpus of example documents to train a machine learning model that extracts the fields based on learned relationships. *Transformer*-based models in particular are good at applying contextual cues to identify patterns, and so are often the basis of a field detection solution.\n\nTraining approaches for field detection machine learning models include:\n\n- **Supervised learning**: Trained on labeled datase",
    "summary": "Instead of hard-coded logic to extract fields based on known names and locations, you can use a corpus of example documents to train a machine learning model that extracts the fields based on learned...",
    "keywords": [
      "structured",
      "such",
      "machine",
      "combines",
      "neural",
      "multi-modal",
      "document",
      "between",
      "attention",
      "-based",
      "patterns",
      "logic",
      "focus",
      "applying",
      "known",
      "text",
      "features",
      "connections",
      "locations",
      "train"
    ]
  },
  {
    "id": 108,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Generative AI for schema-based extraction",
    "content": "Recent advances in large language models (LLMs) have led to the emergence of generative AI-based field detection techniques, which enable more efficient and effective field detection through:\n\n- **Prompt-based extraction** in which you provide the LLM with document text and a schema definition, and it matches the text to the fields in the schema.\n- **Few-shot learning** in which you can train models with minimal examples to extract custom fields.\n- **Chain-of-thought reasoning** that guides mode",
    "summary": "Recent advances in large language models (LLMs) have led to the emergence of generative AI-based field detection techniques, which enable more efficient and effective field detection through:\n\n- **Pro...",
    "keywords": [
      "emergence",
      "extraction",
      "reasoning",
      "few-shot",
      "enable",
      "llms",
      "techniques",
      "minimal",
      "document",
      "field",
      "step-by-step",
      "examples",
      "identification",
      "logic",
      "matches",
      "which",
      "text",
      "learning",
      "more",
      "large"
    ]
  },
  {
    "id": 109,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Stage 3: Field mapping and association",
    "content": "After candidate values are identified, they must be mapped to specific schema fields:",
    "summary": "After candidate values are identified, they must be mapped to specific schema fields:",
    "keywords": [
      "mapping",
      "schema",
      "association",
      "values",
      "after",
      "identified",
      "mapped",
      "they",
      "specific",
      "stage",
      "candidate",
      "field",
      "fields"
    ]
  },
  {
    "id": 110,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Key-value pairing techniques",
    "content": "In many cases, data fields in a document or form are discrete values that can be mapped to keys - for example, the vendor name, date, and total amount in a receipt or invoice. Common techniques used for key-value pairing include:\n\n- **Proximity analysis**:\n    - **Spatial clustering**: Group nearby text elements using distance algorithms.\n    - **Reading order analysis**: Follow natural text flow to associate labels with values.\n    - **Geometric relationships**: Use alignment, indentation, and ",
    "summary": "In many cases, data fields in a document or form are discrete values that can be mapped to keys - for example, the vendor name, date, and total amount in a receipt or invoice. Common techniques used f...",
    "keywords": [
      "follow",
      "example",
      "types",
      "values",
      "name",
      "analyze",
      "understand",
      "mapped",
      "entity",
      "part-of-speech",
      "techniques",
      "group",
      "document",
      "between",
      "natural",
      "labels",
      "reading",
      "flow",
      "patterns",
      "amount"
    ]
  },
  {
    "id": 111,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Table and structured content processing",
    "content": "Some documents include more complex structures of text, such as tables. For example, a receipt or invoice might include a table of line items with columns for the item name, price, and the quantity purchased.\n\nThe presence of a table can be determined using several techniques, including:\n\n- Specialized convolutional neural network (CNN) architectures for table structure recognition.\n- Object detection approaches adapted for table cell identification.\n- Graph-based parsing approaches that model t",
    "summary": "Some documents include more complex structures of text, such as tables. For example, a receipt or invoice might include a table of line items with columns for the item name, price, and the quantity pu...",
    "keywords": [
      "structured",
      "quantity",
      "such",
      "content",
      "example",
      "purchased",
      "adapted",
      "values",
      "documents",
      "name",
      "extraction",
      "specialized",
      "following",
      "neural",
      "understand",
      "meanings",
      "techniques",
      "some",
      "architectures",
      "determined"
    ]
  },
  {
    "id": 112,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Confidence scoring and validation",
    "content": "Field detection and extraction accuracy depends on many factors, and the algorithms and models used to implement the solution are subject to potential misidentification or value interpretation errors. To account for this, various techniques are employed to evaluate the accuracy of the predicted field values; including:\n\n- **OCR confidence**: Inheriting confidence scores from the underlying text recognition.\n- **Pattern matching confidence**: Scoring based on how well extraction matches expected ",
    "summary": "Field detection and extraction accuracy depends on many factors, and the algorithms and models used to implement the solution are subject to potential misidentification or value interpretation errors....",
    "keywords": [
      "confidence",
      "sense",
      "example",
      "values",
      "extraction",
      "scores",
      "checking",
      "predicted",
      "subject",
      "misidentification",
      "techniques",
      "account",
      "context",
      "scoring",
      "depends",
      "underlying",
      "document",
      "well",
      "field",
      "between"
    ]
  },
  {
    "id": 113,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Stage 4: Data normalization and standardization",
    "content": "Raw extracted values are generally transformed into consistent formats (for example to ensure that all extracted dates are expressed in the same date format) and checked for validity.",
    "summary": "Raw extracted values are generally transformed into consistent formats (for example to ensure that all extracted dates are expressed in the same date format) and checked for validity.",
    "keywords": [
      "consistent",
      "example",
      "format",
      "values",
      "standardization",
      "into",
      "checked",
      "stage",
      "ensure",
      "data",
      "extracted",
      "normalization",
      "same",
      "formats",
      "validity",
      "transformed",
      "dates",
      "generally",
      "expressed",
      "date"
    ]
  },
  {
    "id": 114,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Format standardization",
    "content": "Examples of format standardization that can be implemented include:\n\n- **Date normalization**:\n    - **Format detection**: Identify various date formats (MM/DD/YYYY, DD-MM-YYYY, etc.).\n    - **Parsing algorithms**: Convert to standardized ISO formats.\n    - **Ambiguity resolution**: Handle cases where date format is unclear.\n\n- **Currency and numeric processing**:\n    - **Symbol recognition**: Handle different currency symbols and thousand separators.\n    - **Decimal normalization**: Standardize",
    "summary": "Examples of format standardization that can be implemented include:\n\n- **Date normalization**:\n    - **Format detection**: Identify various date formats (MM/DD/YYYY, DD-MM-YYYY, etc.).\n    - **Parsing...",
    "keywords": [
      "ambiguity",
      "consistent",
      "abbreviations",
      "format",
      "conversion",
      "numeric",
      "needed",
      "standardization",
      "thousand",
      "case",
      "point",
      "special",
      "separators",
      "across",
      "full",
      "forms",
      "between",
      "where",
      "standardize",
      "rules"
    ]
  },
  {
    "id": 115,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Data Validation and Quality Assurance",
    "content": "As well as formatting the extracted fields, the standardization process enables further validation of the values that have been extracted through techniques like:\n\n- **Rule-based validation**:\n    - **Format checking**: Verify extracted values match expected patterns (phone numbers, email addresses).\n    - **Range validation**: Ensure numeric values fall within reasonable bounds.\n    - **Required field checking**: Confirm all mandatory fields are present.\n\n- **Statistical validation**:\n    - **O",
    "summary": "As well as formatting the extracted fields, the standardization process enables further validation of the values that have been extracted through techniques like:\n\n- **Rule-based validation**:\n    - *...",
    "keywords": [
      "high",
      "format",
      "present",
      "values",
      "checking",
      "numeric",
      "extraction",
      "standardization",
      "compare",
      "related",
      "documents",
      "techniques",
      "across",
      "historical",
      "numbers",
      "well",
      "assurance",
      "like",
      "patterns",
      "field"
    ]
  },
  {
    "id": 116,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Stage 5: Integration with business processes and systems",
    "content": "The final stage of the process usually involves integrating the extracted field values into a business process or system:",
    "summary": "The final stage of the process usually involves integrating the extracted field values into a business process or system:",
    "keywords": [
      "system",
      "process",
      "final",
      "business",
      "usually",
      "integrating",
      "extracted",
      "values",
      "processes",
      "integration",
      "into",
      "systems",
      "stage",
      "involves",
      "field"
    ]
  },
  {
    "id": 117,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Schema mapping",
    "content": "The extracted fields may need to be further transformed or reformatted so they align with application schemas used for data ingestion into downstream systems. For example:\n\n- **Database schemas**: Map extracted fields to specific database columns and tables.\n- **API payloads**: Format data for REST API consumption by downstream systems.\n- **Message queues**: Prepare structured messages for asynchronous processing.\n\nThe schema mapping process might involve transformations such as:\n\n- **Field rena",
    "summary": "The extracted fields may need to be further transformed or reformatted so they align with application schemas used for data ingestion into downstream systems. For example:\n\n- **Database schemas**: Map...",
    "keywords": [
      "structured",
      "mapping",
      "example",
      "such",
      "types",
      "format",
      "derivation",
      "values",
      "conversion",
      "downstream",
      "into",
      "messages",
      "systems",
      "message",
      "application",
      "involve",
      "field",
      "align",
      "conventions",
      "used"
    ]
  },
  {
    "id": 118,
    "category": "Information Extraction",
    "file": "04-form-extraction.md",
    "heading": "Quality metrics and reporting",
    "content": "Another common task after the extraction process has finished is to evaluate and report on the quality of the extracted data. The report can include information such as:\n\n- **Field-level confidence scores**: Individual confidence ratings for each extracted field.\n- **Document-level quality assessment**: Overall extraction success metrics.\n- **Error categorization**: Classify extraction failures by type and cause.",
    "summary": "Another common task after the extraction process has finished is to evaluate and report on the quality of the extracted data. The report can include information such as:\n\n- **Field-level confidence sc...",
    "keywords": [
      "confidence",
      "such",
      "field-level",
      "individual",
      "scores",
      "extraction",
      "information",
      "reporting",
      "field",
      "finished",
      "process",
      "evaluate",
      "quality",
      "categorization",
      "each",
      "report",
      "data",
      "task",
      "include",
      "classify"
    ]
  }
]